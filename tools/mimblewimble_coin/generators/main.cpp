/*
This file can create the ../../../legacy/firmware/mimblewimble_coin_generators.c file by running the following commands:
wget https://github.com/mimblewimble/secp256k1-zkp/archive/refs/heads/master.zip
unzip master.zip
rm master.zip
cd secp256k1-zkp-master
./autogen.sh
./configure --disable-shared --with-bignum=no --with-field=32bit --with-scalar=32bit
make
sed -i "s/static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;/\/\/static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;/" src/ecmult.h
cd ..
g++ -D USE_NUM_NONE -D USE_FIELD_10X26 -D USE_SCALAR_8X32 -D USE_FIELD_INV_BUILTIN -D USE_SCALAR_INV_BUILTIN main.cpp -I secp256k1-zkp-master/include/ -I secp256k1-zkp-master/src/ -L secp256k1-zkp-master/.libs/ -l secp256k1
./a.out
*/

// Header files
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include "secp256k1_bulletproofs.h"
#include "group_impl.h"
#include "scratch_impl.h"
#include "ecmult_const_impl.h"
#include "field_impl.h"
#include "scalar_impl.h"

using namespace std;


// Definitions

// Bits in a byte
#define BITS_IN_A_BYTE 8

// Big number parts
#define BIG_NUMBER_PARTS 9

// Big number bits per part
#define BIG_NUMBER_BITS_PER_PART 29

// Big number part mask
#define BIG_NUMBER_PART_MASK ((1 << BIG_NUMBER_BITS_PER_PART) - 1)

// Big number extra bits
#define BIG_NUMBER_EXTRA_BITS (sizeof(uint32_t) * BITS_IN_A_BYTE - BIG_NUMBER_BITS_PER_PART)


// Structures

// Secp256k1 bulletproof generators
struct secp256k1_bulletproof_generators {

	// Number of generators
	size_t numberOfGenerators;
	
	// Generators
	secp256k1_ge *generators;
	
	// Blinding generator
	secp256k1_ge *blindingGenerator;
};

// Big number
struct BigNumber {

	// Parts
	uint32_t parts[BIG_NUMBER_PARTS];
};


// Constants

// Number of generators
static const size_t NUMBER_OF_GENERATORS = 128;

// Component size
static const size_t COMPONENT_SIZE = 32;

// File location
static const char *FILE_LOCATION = "../../../legacy/firmware/mimblewimble_coin_generators.c";

// Hexadecimal character size
static const size_t HEXADECIMAL_CHARACTER_SIZE = sizeof("FF") - sizeof('\0');

// Hexadecimal padding character
static const char HEXADECIMAL_PADDING_CHARACTER = '0';

// Window size
static const uint8_t WINDOW_SIZE = 6;

// Number of odd multiples
static const uint8_t NUMBER_OF_ODD_MULTIPLES = 1 << (WINDOW_SIZE - 2);


struct secp256k1_context_struct {
    secp256k1_ecmult_context ecmult_ctx;
};


// Function prototypes

// To big number
BigNumber toBigNumber(const uint8_t *component);


// Main function
int main() {

	// Create context
	secp256k1_context *context = secp256k1_context_create(SECP256K1_CONTEXT_NONE);
	
	// Create generators
	secp256k1_bulletproof_generators *generators = secp256k1_bulletproof_generators_create(context, &secp256k1_generator_const_g, 256);
	
	// Create file
	ofstream file(FILE_LOCATION, ofstream::binary);
	
	// Write start of file to file
	file << "// This file is generated by ../../tools/mimblewimble_coin/generators/main.cpp" << endl;
	file << endl;
	file << "// Header files" << endl;
	file << "#include \"mimblewimble_coin_generators.h\"" << endl;
	file << endl;
	file << endl;
	file << "// Constants" << endl;
	file << endl;
	
	// Write start of generators to file
	file << "// Generators" << endl;
	file << "const curve_point MIMBLEWIMBLE_COIN_GENERATORS[MIMBLEWIMBLE_COIN_NUMBER_OF_GENERATORS * MIMBLEWIMBLE_COIN_NUMBER_OF_ODD_GENERATOR_MULTIPLES] = {" << endl;
	
	// Go through all of the generators
	for(size_t i = 0; i < NUMBER_OF_GENERATORS; ++i) {
	
		// Get generator
		const secp256k1_ge &generator = (i % 2 == 0) ? generators->generators[i / 2] : generators->generators[i / 2 + generators->numberOfGenerators / 2];
		
		// Go through all odd multiples
		for(uint8_t j = 0; j < NUMBER_OF_ODD_MULTIPLES; ++j) {
		
			// Get odd power
			secp256k1_scalar oddPower;
			secp256k1_scalar_set_int(&oddPower, 2 * j + 1);
			
			// Multiply generator by the odd power
			secp256k1_gej generatorToPower;
			secp256k1_ecmult_const(&generatorToPower, &generator, &oddPower, 256);
			
			// Get result in affine coordinates
			secp256k1_ge generatorToPowerAffine;
			secp256k1_ge_set_gej(&generatorToPowerAffine, &generatorToPower);
			
			// Get result in affine coordinates's components
			uint8_t components[2 * COMPONENT_SIZE];
			secp256k1_fe_get_b32(components, &generatorToPowerAffine.x);
			secp256k1_fe_get_b32(&components[COMPONENT_SIZE], &generatorToPowerAffine.y);
			
			// Write start of generator's x component to file
			file << "\t{" << endl << "\t\t.x = {";
			
			// Get x component as big numbers
			const BigNumber xComponent = toBigNumber(components);
			
			// Go through all parts in the x component
			for(size_t k = 0; k < BIG_NUMBER_PARTS; ++k) {
			
				// Write part to file
				file << "0x" << hex << uppercase << setfill(HEXADECIMAL_PADDING_CHARACTER) << setw(HEXADECIMAL_CHARACTER_SIZE * sizeof(xComponent.parts[k])) << right << xComponent.parts[k] << ((k != BIG_NUMBER_PARTS - 1) ? ", " : "");
			}
			
			// Write start of generator's y component to file
			file << "}," << endl << "\t\t.y = {";
			
			// Get y component as big numbers
			const BigNumber yComponent = toBigNumber(&components[COMPONENT_SIZE]);
			
			// Go through all parts in the y component
			for(size_t k = 0; k < BIG_NUMBER_PARTS; ++k) {
			
				// Write part to file
				file << "0x" << hex << uppercase << setfill(HEXADECIMAL_PADDING_CHARACTER) << setw(HEXADECIMAL_CHARACTER_SIZE * sizeof(yComponent.parts[k])) << right << yComponent.parts[k] << ((k != BIG_NUMBER_PARTS - 1) ? ", " : "");
			}
			
			// Write end of generator's y component to file
			file << '}' << endl << "\t}" << ((i != NUMBER_OF_GENERATORS - 1 || j != NUMBER_OF_ODD_MULTIPLES - 1) ? "," : "") << endl;
		}
	}
	
	// Write end of generators to file
	file << "};" << endl;
	
	// Display message
	cout << "Created " << FILE_LOCATION << endl;
	
	// Destroy generators
	secp256k1_bulletproof_generators_destroy(context, generators);
	
	// Destroy context
	secp256k1_context_destroy(context);
	
	// Return success
	return EXIT_SUCCESS;
}


// Supporting function implementation

// To big number
BigNumber toBigNumber(const uint8_t *component) {

	// Initialize result
	BigNumber result;
	
	// Go through all parts of the big number
	uint32_t currentBits = 0;
	for(size_t i = 0; i < BIG_NUMBER_PARTS - 1; ++i) {
	
		// Get bits from component
		uint32_t bits = *reinterpret_cast<const uint32_t *>(&component[(BIG_NUMBER_PARTS - 1 - i - 1) * sizeof(uint32_t)]);
		
		// Check if system is little endian
		#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
		
			// Convert bits to bit endian
			bits = __builtin_bswap32(bits);
		#endif
		
		// Prepend bits to current bits
		currentBits |= bits << (BIG_NUMBER_EXTRA_BITS * i);
		
		// Set result's part to the current bits
		result.parts[i] = currentBits & BIG_NUMBER_PART_MASK;
		
		// Remove used bits from current bits
		currentBits = bits >> (sizeof(uint32_t) * BITS_IN_A_BYTE - BIG_NUMBER_EXTRA_BITS * (i + 1));
	}
	
	// Set result's last part to remaining current bits
	result.parts[BIG_NUMBER_PARTS - 1] = currentBits;
	
	// Return result
	return result;
}
