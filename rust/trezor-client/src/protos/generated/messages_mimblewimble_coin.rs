// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `messages-mimblewimble-coin.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetRootPublicKey)
pub struct MimbleWimbleCoinGetRootPublicKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetRootPublicKey.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetRootPublicKey.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetRootPublicKey.account)
    pub account: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetRootPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinGetRootPublicKey {
    fn default() -> &'a MimbleWimbleCoinGetRootPublicKey {
        <MimbleWimbleCoinGetRootPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinGetRootPublicKey {
    pub fn new() -> MimbleWimbleCoinGetRootPublicKey {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinGetRootPublicKey| { &m.coin_type },
            |m: &mut MimbleWimbleCoinGetRootPublicKey| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinGetRootPublicKey| { &m.network_type },
            |m: &mut MimbleWimbleCoinGetRootPublicKey| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinGetRootPublicKey| { &m.account },
            |m: &mut MimbleWimbleCoinGetRootPublicKey| { &mut m.account },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinGetRootPublicKey>(
            "MimbleWimbleCoinGetRootPublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinGetRootPublicKey {
    const NAME: &'static str = "MimbleWimbleCoinGetRootPublicKey";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinGetRootPublicKey {
        MimbleWimbleCoinGetRootPublicKey::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinGetRootPublicKey {
        static instance: MimbleWimbleCoinGetRootPublicKey = MimbleWimbleCoinGetRootPublicKey {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinGetRootPublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinGetRootPublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinGetRootPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinGetRootPublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinRootPublicKey)
pub struct MimbleWimbleCoinRootPublicKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinRootPublicKey.root_public_key)
    pub root_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinRootPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinRootPublicKey {
    fn default() -> &'a MimbleWimbleCoinRootPublicKey {
        <MimbleWimbleCoinRootPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinRootPublicKey {
    pub fn new() -> MimbleWimbleCoinRootPublicKey {
        ::std::default::Default::default()
    }

    // required bytes root_public_key = 1;

    pub fn root_public_key(&self) -> &[u8] {
        match self.root_public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_root_public_key(&mut self) {
        self.root_public_key = ::std::option::Option::None;
    }

    pub fn has_root_public_key(&self) -> bool {
        self.root_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.root_public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.root_public_key.is_none() {
            self.root_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.root_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_root_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.root_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "root_public_key",
            |m: &MimbleWimbleCoinRootPublicKey| { &m.root_public_key },
            |m: &mut MimbleWimbleCoinRootPublicKey| { &mut m.root_public_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinRootPublicKey>(
            "MimbleWimbleCoinRootPublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinRootPublicKey {
    const NAME: &'static str = "MimbleWimbleCoinRootPublicKey";

    fn is_initialized(&self) -> bool {
        if self.root_public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.root_public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.root_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.root_public_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinRootPublicKey {
        MimbleWimbleCoinRootPublicKey::new()
    }

    fn clear(&mut self) {
        self.root_public_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinRootPublicKey {
        static instance: MimbleWimbleCoinRootPublicKey = MimbleWimbleCoinRootPublicKey {
            root_public_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinRootPublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinRootPublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinRootPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinRootPublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetAddress)
pub struct MimbleWimbleCoinGetAddress {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetAddress.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetAddress.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetAddress.address_type)
    pub address_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinAddressType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetAddress.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetAddress.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinGetAddress {
    fn default() -> &'a MimbleWimbleCoinGetAddress {
        <MimbleWimbleCoinGetAddress as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinGetAddress {
    pub fn new() -> MimbleWimbleCoinGetAddress {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddressType address_type = 3;

    pub fn address_type(&self) -> MimbleWimbleCoinAddressType {
        match self.address_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinAddressType::MQS),
            None => MimbleWimbleCoinAddressType::MQS,
        }
    }

    pub fn clear_address_type(&mut self) {
        self.address_type = ::std::option::Option::None;
    }

    pub fn has_address_type(&self) -> bool {
        self.address_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address_type(&mut self, v: MimbleWimbleCoinAddressType) {
        self.address_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 4;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required uint32 index = 5;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinGetAddress| { &m.coin_type },
            |m: &mut MimbleWimbleCoinGetAddress| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinGetAddress| { &m.network_type },
            |m: &mut MimbleWimbleCoinGetAddress| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address_type",
            |m: &MimbleWimbleCoinGetAddress| { &m.address_type },
            |m: &mut MimbleWimbleCoinGetAddress| { &mut m.address_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinGetAddress| { &m.account },
            |m: &mut MimbleWimbleCoinGetAddress| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &MimbleWimbleCoinGetAddress| { &m.index },
            |m: &mut MimbleWimbleCoinGetAddress| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinGetAddress>(
            "MimbleWimbleCoinGetAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinGetAddress {
    const NAME: &'static str = "MimbleWimbleCoinGetAddress";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.address_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.address_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.address_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.address_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinGetAddress {
        MimbleWimbleCoinGetAddress::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.address_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinGetAddress {
        static instance: MimbleWimbleCoinGetAddress = MimbleWimbleCoinGetAddress {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            address_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinGetAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinGetAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinGetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinGetAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddress)
pub struct MimbleWimbleCoinAddress {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddress.address)
    pub address: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinAddress {
    fn default() -> &'a MimbleWimbleCoinAddress {
        <MimbleWimbleCoinAddress as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinAddress {
    pub fn new() -> MimbleWimbleCoinAddress {
        ::std::default::Default::default()
    }

    // required string address = 1;

    pub fn address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &MimbleWimbleCoinAddress| { &m.address },
            |m: &mut MimbleWimbleCoinAddress| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinAddress>(
            "MimbleWimbleCoinAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinAddress {
    const NAME: &'static str = "MimbleWimbleCoinAddress";

    fn is_initialized(&self) -> bool {
        if self.address.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.address.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinAddress {
        MimbleWimbleCoinAddress::new()
    }

    fn clear(&mut self) {
        self.address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinAddress {
        static instance: MimbleWimbleCoinAddress = MimbleWimbleCoinAddress {
            address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetSeedCookie)
pub struct MimbleWimbleCoinGetSeedCookie {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetSeedCookie.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetSeedCookie.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetSeedCookie.account)
    pub account: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetSeedCookie.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinGetSeedCookie {
    fn default() -> &'a MimbleWimbleCoinGetSeedCookie {
        <MimbleWimbleCoinGetSeedCookie as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinGetSeedCookie {
    pub fn new() -> MimbleWimbleCoinGetSeedCookie {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinGetSeedCookie| { &m.coin_type },
            |m: &mut MimbleWimbleCoinGetSeedCookie| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinGetSeedCookie| { &m.network_type },
            |m: &mut MimbleWimbleCoinGetSeedCookie| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinGetSeedCookie| { &m.account },
            |m: &mut MimbleWimbleCoinGetSeedCookie| { &mut m.account },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinGetSeedCookie>(
            "MimbleWimbleCoinGetSeedCookie",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinGetSeedCookie {
    const NAME: &'static str = "MimbleWimbleCoinGetSeedCookie";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinGetSeedCookie {
        MimbleWimbleCoinGetSeedCookie::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinGetSeedCookie {
        static instance: MimbleWimbleCoinGetSeedCookie = MimbleWimbleCoinGetSeedCookie {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinGetSeedCookie {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinGetSeedCookie").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinGetSeedCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinGetSeedCookie {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSeedCookie)
pub struct MimbleWimbleCoinSeedCookie {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSeedCookie.seed_cookie)
    pub seed_cookie: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSeedCookie.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinSeedCookie {
    fn default() -> &'a MimbleWimbleCoinSeedCookie {
        <MimbleWimbleCoinSeedCookie as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinSeedCookie {
    pub fn new() -> MimbleWimbleCoinSeedCookie {
        ::std::default::Default::default()
    }

    // required bytes seed_cookie = 1;

    pub fn seed_cookie(&self) -> &[u8] {
        match self.seed_cookie.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_seed_cookie(&mut self) {
        self.seed_cookie = ::std::option::Option::None;
    }

    pub fn has_seed_cookie(&self) -> bool {
        self.seed_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed_cookie(&mut self, v: ::std::vec::Vec<u8>) {
        self.seed_cookie = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed_cookie(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.seed_cookie.is_none() {
            self.seed_cookie = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.seed_cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_seed_cookie(&mut self) -> ::std::vec::Vec<u8> {
        self.seed_cookie.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seed_cookie",
            |m: &MimbleWimbleCoinSeedCookie| { &m.seed_cookie },
            |m: &mut MimbleWimbleCoinSeedCookie| { &mut m.seed_cookie },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinSeedCookie>(
            "MimbleWimbleCoinSeedCookie",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinSeedCookie {
    const NAME: &'static str = "MimbleWimbleCoinSeedCookie";

    fn is_initialized(&self) -> bool {
        if self.seed_cookie.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.seed_cookie = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seed_cookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seed_cookie.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinSeedCookie {
        MimbleWimbleCoinSeedCookie::new()
    }

    fn clear(&mut self) {
        self.seed_cookie = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinSeedCookie {
        static instance: MimbleWimbleCoinSeedCookie = MimbleWimbleCoinSeedCookie {
            seed_cookie: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinSeedCookie {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinSeedCookie").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinSeedCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinSeedCookie {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetCommitment)
pub struct MimbleWimbleCoinGetCommitment {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetCommitment.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetCommitment.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetCommitment.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetCommitment.identifier)
    pub identifier: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetCommitment.value)
    pub value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetCommitment.switch_type)
    pub switch_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinSwitchType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetCommitment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinGetCommitment {
    fn default() -> &'a MimbleWimbleCoinGetCommitment {
        <MimbleWimbleCoinGetCommitment as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinGetCommitment {
    pub fn new() -> MimbleWimbleCoinGetCommitment {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required bytes identifier = 4;

    pub fn identifier(&self) -> &[u8] {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::vec::Vec<u8> {
        self.identifier.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 value = 5;

    pub fn value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchType switch_type = 6;

    pub fn switch_type(&self) -> MimbleWimbleCoinSwitchType {
        match self.switch_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinSwitchType::NONE),
            None => MimbleWimbleCoinSwitchType::NONE,
        }
    }

    pub fn clear_switch_type(&mut self) {
        self.switch_type = ::std::option::Option::None;
    }

    pub fn has_switch_type(&self) -> bool {
        self.switch_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_switch_type(&mut self, v: MimbleWimbleCoinSwitchType) {
        self.switch_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinGetCommitment| { &m.coin_type },
            |m: &mut MimbleWimbleCoinGetCommitment| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinGetCommitment| { &m.network_type },
            |m: &mut MimbleWimbleCoinGetCommitment| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinGetCommitment| { &m.account },
            |m: &mut MimbleWimbleCoinGetCommitment| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &MimbleWimbleCoinGetCommitment| { &m.identifier },
            |m: &mut MimbleWimbleCoinGetCommitment| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &MimbleWimbleCoinGetCommitment| { &m.value },
            |m: &mut MimbleWimbleCoinGetCommitment| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "switch_type",
            |m: &MimbleWimbleCoinGetCommitment| { &m.switch_type },
            |m: &mut MimbleWimbleCoinGetCommitment| { &mut m.switch_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinGetCommitment>(
            "MimbleWimbleCoinGetCommitment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinGetCommitment {
    const NAME: &'static str = "MimbleWimbleCoinGetCommitment";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.identifier.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        if self.switch_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.identifier = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.value = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.switch_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.switch_type {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.identifier.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.switch_type {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinGetCommitment {
        MimbleWimbleCoinGetCommitment::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.switch_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinGetCommitment {
        static instance: MimbleWimbleCoinGetCommitment = MimbleWimbleCoinGetCommitment {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            value: ::std::option::Option::None,
            switch_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinGetCommitment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinGetCommitment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinGetCommitment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinGetCommitment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCommitment)
pub struct MimbleWimbleCoinCommitment {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCommitment.commitment)
    pub commitment: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCommitment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinCommitment {
    fn default() -> &'a MimbleWimbleCoinCommitment {
        <MimbleWimbleCoinCommitment as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinCommitment {
    pub fn new() -> MimbleWimbleCoinCommitment {
        ::std::default::Default::default()
    }

    // required bytes commitment = 1;

    pub fn commitment(&self) -> &[u8] {
        match self.commitment.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_commitment(&mut self) {
        self.commitment = ::std::option::Option::None;
    }

    pub fn has_commitment(&self) -> bool {
        self.commitment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.commitment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.commitment.is_none() {
            self.commitment = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.commitment.as_mut().unwrap()
    }

    // Take field
    pub fn take_commitment(&mut self) -> ::std::vec::Vec<u8> {
        self.commitment.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commitment",
            |m: &MimbleWimbleCoinCommitment| { &m.commitment },
            |m: &mut MimbleWimbleCoinCommitment| { &mut m.commitment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinCommitment>(
            "MimbleWimbleCoinCommitment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinCommitment {
    const NAME: &'static str = "MimbleWimbleCoinCommitment";

    fn is_initialized(&self) -> bool {
        if self.commitment.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commitment = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commitment.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.commitment.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinCommitment {
        MimbleWimbleCoinCommitment::new()
    }

    fn clear(&mut self) {
        self.commitment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinCommitment {
        static instance: MimbleWimbleCoinCommitment = MimbleWimbleCoinCommitment {
            commitment: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinCommitment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinCommitment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinCommitment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinCommitment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents)
pub struct MimbleWimbleCoinGetBulletproofComponents {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents.message_type)
    pub message_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinMessageType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents.identifier)
    pub identifier: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents.value)
    pub value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents.switch_type)
    pub switch_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinSwitchType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetBulletproofComponents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinGetBulletproofComponents {
    fn default() -> &'a MimbleWimbleCoinGetBulletproofComponents {
        <MimbleWimbleCoinGetBulletproofComponents as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinGetBulletproofComponents {
    pub fn new() -> MimbleWimbleCoinGetBulletproofComponents {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinMessageType message_type = 3;

    pub fn message_type(&self) -> MimbleWimbleCoinMessageType {
        match self.message_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinMessageType::SENDING_TRANSACTION),
            None => MimbleWimbleCoinMessageType::SENDING_TRANSACTION,
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: MimbleWimbleCoinMessageType) {
        self.message_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 4;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required bytes identifier = 5;

    pub fn identifier(&self) -> &[u8] {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::vec::Vec<u8> {
        self.identifier.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 value = 6;

    pub fn value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchType switch_type = 7;

    pub fn switch_type(&self) -> MimbleWimbleCoinSwitchType {
        match self.switch_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinSwitchType::NONE),
            None => MimbleWimbleCoinSwitchType::NONE,
        }
    }

    pub fn clear_switch_type(&mut self) {
        self.switch_type = ::std::option::Option::None;
    }

    pub fn has_switch_type(&self) -> bool {
        self.switch_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_switch_type(&mut self, v: MimbleWimbleCoinSwitchType) {
        self.switch_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinGetBulletproofComponents| { &m.coin_type },
            |m: &mut MimbleWimbleCoinGetBulletproofComponents| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinGetBulletproofComponents| { &m.network_type },
            |m: &mut MimbleWimbleCoinGetBulletproofComponents| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_type",
            |m: &MimbleWimbleCoinGetBulletproofComponents| { &m.message_type },
            |m: &mut MimbleWimbleCoinGetBulletproofComponents| { &mut m.message_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinGetBulletproofComponents| { &m.account },
            |m: &mut MimbleWimbleCoinGetBulletproofComponents| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &MimbleWimbleCoinGetBulletproofComponents| { &m.identifier },
            |m: &mut MimbleWimbleCoinGetBulletproofComponents| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &MimbleWimbleCoinGetBulletproofComponents| { &m.value },
            |m: &mut MimbleWimbleCoinGetBulletproofComponents| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "switch_type",
            |m: &MimbleWimbleCoinGetBulletproofComponents| { &m.switch_type },
            |m: &mut MimbleWimbleCoinGetBulletproofComponents| { &mut m.switch_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinGetBulletproofComponents>(
            "MimbleWimbleCoinGetBulletproofComponents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinGetBulletproofComponents {
    const NAME: &'static str = "MimbleWimbleCoinGetBulletproofComponents";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.message_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.identifier.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        if self.switch_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.message_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.identifier = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.value = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.switch_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.message_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.switch_type {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.message_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.identifier.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.switch_type {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinGetBulletproofComponents {
        MimbleWimbleCoinGetBulletproofComponents::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.switch_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinGetBulletproofComponents {
        static instance: MimbleWimbleCoinGetBulletproofComponents = MimbleWimbleCoinGetBulletproofComponents {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            message_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            value: ::std::option::Option::None,
            switch_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinGetBulletproofComponents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinGetBulletproofComponents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinGetBulletproofComponents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinGetBulletproofComponents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinBulletproofComponents)
pub struct MimbleWimbleCoinBulletproofComponents {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinBulletproofComponents.tau_x)
    pub tau_x: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinBulletproofComponents.t_one)
    pub t_one: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinBulletproofComponents.t_two)
    pub t_two: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinBulletproofComponents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinBulletproofComponents {
    fn default() -> &'a MimbleWimbleCoinBulletproofComponents {
        <MimbleWimbleCoinBulletproofComponents as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinBulletproofComponents {
    pub fn new() -> MimbleWimbleCoinBulletproofComponents {
        ::std::default::Default::default()
    }

    // required bytes tau_x = 1;

    pub fn tau_x(&self) -> &[u8] {
        match self.tau_x.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tau_x(&mut self) {
        self.tau_x = ::std::option::Option::None;
    }

    pub fn has_tau_x(&self) -> bool {
        self.tau_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tau_x(&mut self, v: ::std::vec::Vec<u8>) {
        self.tau_x = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tau_x(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tau_x.is_none() {
            self.tau_x = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tau_x.as_mut().unwrap()
    }

    // Take field
    pub fn take_tau_x(&mut self) -> ::std::vec::Vec<u8> {
        self.tau_x.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes t_one = 2;

    pub fn t_one(&self) -> &[u8] {
        match self.t_one.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_t_one(&mut self) {
        self.t_one = ::std::option::Option::None;
    }

    pub fn has_t_one(&self) -> bool {
        self.t_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t_one(&mut self, v: ::std::vec::Vec<u8>) {
        self.t_one = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t_one(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.t_one.is_none() {
            self.t_one = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.t_one.as_mut().unwrap()
    }

    // Take field
    pub fn take_t_one(&mut self) -> ::std::vec::Vec<u8> {
        self.t_one.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes t_two = 3;

    pub fn t_two(&self) -> &[u8] {
        match self.t_two.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_t_two(&mut self) {
        self.t_two = ::std::option::Option::None;
    }

    pub fn has_t_two(&self) -> bool {
        self.t_two.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t_two(&mut self, v: ::std::vec::Vec<u8>) {
        self.t_two = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t_two(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.t_two.is_none() {
            self.t_two = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.t_two.as_mut().unwrap()
    }

    // Take field
    pub fn take_t_two(&mut self) -> ::std::vec::Vec<u8> {
        self.t_two.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tau_x",
            |m: &MimbleWimbleCoinBulletproofComponents| { &m.tau_x },
            |m: &mut MimbleWimbleCoinBulletproofComponents| { &mut m.tau_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "t_one",
            |m: &MimbleWimbleCoinBulletproofComponents| { &m.t_one },
            |m: &mut MimbleWimbleCoinBulletproofComponents| { &mut m.t_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "t_two",
            |m: &MimbleWimbleCoinBulletproofComponents| { &m.t_two },
            |m: &mut MimbleWimbleCoinBulletproofComponents| { &mut m.t_two },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinBulletproofComponents>(
            "MimbleWimbleCoinBulletproofComponents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinBulletproofComponents {
    const NAME: &'static str = "MimbleWimbleCoinBulletproofComponents";

    fn is_initialized(&self) -> bool {
        if self.tau_x.is_none() {
            return false;
        }
        if self.t_one.is_none() {
            return false;
        }
        if self.t_two.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tau_x = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.t_one = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.t_two = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tau_x.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.t_one.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.t_two.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tau_x.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.t_one.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.t_two.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinBulletproofComponents {
        MimbleWimbleCoinBulletproofComponents::new()
    }

    fn clear(&mut self) {
        self.tau_x = ::std::option::Option::None;
        self.t_one = ::std::option::Option::None;
        self.t_two = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinBulletproofComponents {
        static instance: MimbleWimbleCoinBulletproofComponents = MimbleWimbleCoinBulletproofComponents {
            tau_x: ::std::option::Option::None,
            t_one: ::std::option::Option::None,
            t_two: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinBulletproofComponents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinBulletproofComponents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinBulletproofComponents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinBulletproofComponents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyRootPublicKey)
pub struct MimbleWimbleCoinVerifyRootPublicKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyRootPublicKey.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyRootPublicKey.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyRootPublicKey.account)
    pub account: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyRootPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinVerifyRootPublicKey {
    fn default() -> &'a MimbleWimbleCoinVerifyRootPublicKey {
        <MimbleWimbleCoinVerifyRootPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinVerifyRootPublicKey {
    pub fn new() -> MimbleWimbleCoinVerifyRootPublicKey {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinVerifyRootPublicKey| { &m.coin_type },
            |m: &mut MimbleWimbleCoinVerifyRootPublicKey| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinVerifyRootPublicKey| { &m.network_type },
            |m: &mut MimbleWimbleCoinVerifyRootPublicKey| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinVerifyRootPublicKey| { &m.account },
            |m: &mut MimbleWimbleCoinVerifyRootPublicKey| { &mut m.account },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinVerifyRootPublicKey>(
            "MimbleWimbleCoinVerifyRootPublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinVerifyRootPublicKey {
    const NAME: &'static str = "MimbleWimbleCoinVerifyRootPublicKey";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinVerifyRootPublicKey {
        MimbleWimbleCoinVerifyRootPublicKey::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinVerifyRootPublicKey {
        static instance: MimbleWimbleCoinVerifyRootPublicKey = MimbleWimbleCoinVerifyRootPublicKey {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinVerifyRootPublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinVerifyRootPublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinVerifyRootPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinVerifyRootPublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyAddress)
pub struct MimbleWimbleCoinVerifyAddress {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyAddress.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyAddress.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyAddress.address_type)
    pub address_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinAddressType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyAddress.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyAddress.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinVerifyAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinVerifyAddress {
    fn default() -> &'a MimbleWimbleCoinVerifyAddress {
        <MimbleWimbleCoinVerifyAddress as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinVerifyAddress {
    pub fn new() -> MimbleWimbleCoinVerifyAddress {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddressType address_type = 3;

    pub fn address_type(&self) -> MimbleWimbleCoinAddressType {
        match self.address_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinAddressType::MQS),
            None => MimbleWimbleCoinAddressType::MQS,
        }
    }

    pub fn clear_address_type(&mut self) {
        self.address_type = ::std::option::Option::None;
    }

    pub fn has_address_type(&self) -> bool {
        self.address_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address_type(&mut self, v: MimbleWimbleCoinAddressType) {
        self.address_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 4;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required uint32 index = 5;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinVerifyAddress| { &m.coin_type },
            |m: &mut MimbleWimbleCoinVerifyAddress| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinVerifyAddress| { &m.network_type },
            |m: &mut MimbleWimbleCoinVerifyAddress| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address_type",
            |m: &MimbleWimbleCoinVerifyAddress| { &m.address_type },
            |m: &mut MimbleWimbleCoinVerifyAddress| { &mut m.address_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinVerifyAddress| { &m.account },
            |m: &mut MimbleWimbleCoinVerifyAddress| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &MimbleWimbleCoinVerifyAddress| { &m.index },
            |m: &mut MimbleWimbleCoinVerifyAddress| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinVerifyAddress>(
            "MimbleWimbleCoinVerifyAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinVerifyAddress {
    const NAME: &'static str = "MimbleWimbleCoinVerifyAddress";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.address_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.address_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.address_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.address_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinVerifyAddress {
        MimbleWimbleCoinVerifyAddress::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.address_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinVerifyAddress {
        static instance: MimbleWimbleCoinVerifyAddress = MimbleWimbleCoinVerifyAddress {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            address_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinVerifyAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinVerifyAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinVerifyAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinVerifyAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartEncryptingSlate)
pub struct MimbleWimbleCoinStartEncryptingSlate {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartEncryptingSlate.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartEncryptingSlate.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartEncryptingSlate.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartEncryptingSlate.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartEncryptingSlate.recipient_address)
    pub recipient_address: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartEncryptingSlate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinStartEncryptingSlate {
    fn default() -> &'a MimbleWimbleCoinStartEncryptingSlate {
        <MimbleWimbleCoinStartEncryptingSlate as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinStartEncryptingSlate {
    pub fn new() -> MimbleWimbleCoinStartEncryptingSlate {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required uint32 index = 4;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // required bytes recipient_address = 5;

    pub fn recipient_address(&self) -> &[u8] {
        match self.recipient_address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_recipient_address(&mut self) {
        self.recipient_address = ::std::option::Option::None;
    }

    pub fn has_recipient_address(&self) -> bool {
        self.recipient_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.recipient_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.recipient_address.is_none() {
            self.recipient_address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.recipient_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipient_address(&mut self) -> ::std::vec::Vec<u8> {
        self.recipient_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinStartEncryptingSlate| { &m.coin_type },
            |m: &mut MimbleWimbleCoinStartEncryptingSlate| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinStartEncryptingSlate| { &m.network_type },
            |m: &mut MimbleWimbleCoinStartEncryptingSlate| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinStartEncryptingSlate| { &m.account },
            |m: &mut MimbleWimbleCoinStartEncryptingSlate| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &MimbleWimbleCoinStartEncryptingSlate| { &m.index },
            |m: &mut MimbleWimbleCoinStartEncryptingSlate| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipient_address",
            |m: &MimbleWimbleCoinStartEncryptingSlate| { &m.recipient_address },
            |m: &mut MimbleWimbleCoinStartEncryptingSlate| { &mut m.recipient_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinStartEncryptingSlate>(
            "MimbleWimbleCoinStartEncryptingSlate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinStartEncryptingSlate {
    const NAME: &'static str = "MimbleWimbleCoinStartEncryptingSlate";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        if self.recipient_address.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.recipient_address = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.recipient_address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.recipient_address.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinStartEncryptingSlate {
        MimbleWimbleCoinStartEncryptingSlate::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.recipient_address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinStartEncryptingSlate {
        static instance: MimbleWimbleCoinStartEncryptingSlate = MimbleWimbleCoinStartEncryptingSlate {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            index: ::std::option::Option::None,
            recipient_address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinStartEncryptingSlate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinStartEncryptingSlate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinStartEncryptingSlate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinStartEncryptingSlate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateNonceAndSalt)
pub struct MimbleWimbleCoinEncryptedSlateNonceAndSalt {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateNonceAndSalt.nonce)
    pub nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateNonceAndSalt.salt)
    pub salt: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateNonceAndSalt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinEncryptedSlateNonceAndSalt {
    fn default() -> &'a MimbleWimbleCoinEncryptedSlateNonceAndSalt {
        <MimbleWimbleCoinEncryptedSlateNonceAndSalt as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinEncryptedSlateNonceAndSalt {
    pub fn new() -> MimbleWimbleCoinEncryptedSlateNonceAndSalt {
        ::std::default::Default::default()
    }

    // required bytes nonce = 1;

    pub fn nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes salt = 2;

    pub fn salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_salt(&mut self) {
        self.salt = ::std::option::Option::None;
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nonce",
            |m: &MimbleWimbleCoinEncryptedSlateNonceAndSalt| { &m.nonce },
            |m: &mut MimbleWimbleCoinEncryptedSlateNonceAndSalt| { &mut m.nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salt",
            |m: &MimbleWimbleCoinEncryptedSlateNonceAndSalt| { &m.salt },
            |m: &mut MimbleWimbleCoinEncryptedSlateNonceAndSalt| { &mut m.salt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinEncryptedSlateNonceAndSalt>(
            "MimbleWimbleCoinEncryptedSlateNonceAndSalt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinEncryptedSlateNonceAndSalt {
    const NAME: &'static str = "MimbleWimbleCoinEncryptedSlateNonceAndSalt";

    fn is_initialized(&self) -> bool {
        if self.nonce.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.salt = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.nonce.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.salt.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinEncryptedSlateNonceAndSalt {
        MimbleWimbleCoinEncryptedSlateNonceAndSalt::new()
    }

    fn clear(&mut self) {
        self.nonce = ::std::option::Option::None;
        self.salt = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinEncryptedSlateNonceAndSalt {
        static instance: MimbleWimbleCoinEncryptedSlateNonceAndSalt = MimbleWimbleCoinEncryptedSlateNonceAndSalt {
            nonce: ::std::option::Option::None,
            salt: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinEncryptedSlateNonceAndSalt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinEncryptedSlateNonceAndSalt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinEncryptedSlateNonceAndSalt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinEncryptedSlateNonceAndSalt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueEncryptingSlate)
pub struct MimbleWimbleCoinContinueEncryptingSlate {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueEncryptingSlate.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueEncryptingSlate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinContinueEncryptingSlate {
    fn default() -> &'a MimbleWimbleCoinContinueEncryptingSlate {
        <MimbleWimbleCoinContinueEncryptingSlate as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinContinueEncryptingSlate {
    pub fn new() -> MimbleWimbleCoinContinueEncryptingSlate {
        ::std::default::Default::default()
    }

    // required bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &MimbleWimbleCoinContinueEncryptingSlate| { &m.data },
            |m: &mut MimbleWimbleCoinContinueEncryptingSlate| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinContinueEncryptingSlate>(
            "MimbleWimbleCoinContinueEncryptingSlate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinContinueEncryptingSlate {
    const NAME: &'static str = "MimbleWimbleCoinContinueEncryptingSlate";

    fn is_initialized(&self) -> bool {
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinContinueEncryptingSlate {
        MimbleWimbleCoinContinueEncryptingSlate::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinContinueEncryptingSlate {
        static instance: MimbleWimbleCoinContinueEncryptingSlate = MimbleWimbleCoinContinueEncryptingSlate {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinContinueEncryptingSlate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinContinueEncryptingSlate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinContinueEncryptingSlate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinContinueEncryptingSlate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateData)
pub struct MimbleWimbleCoinEncryptedSlateData {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateData.encrypted_data)
    pub encrypted_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinEncryptedSlateData {
    fn default() -> &'a MimbleWimbleCoinEncryptedSlateData {
        <MimbleWimbleCoinEncryptedSlateData as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinEncryptedSlateData {
    pub fn new() -> MimbleWimbleCoinEncryptedSlateData {
        ::std::default::Default::default()
    }

    // required bytes encrypted_data = 1;

    pub fn encrypted_data(&self) -> &[u8] {
        match self.encrypted_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_data(&mut self) {
        self.encrypted_data = ::std::option::Option::None;
    }

    pub fn has_encrypted_data(&self) -> bool {
        self.encrypted_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_data.is_none() {
            self.encrypted_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encrypted_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_data(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted_data",
            |m: &MimbleWimbleCoinEncryptedSlateData| { &m.encrypted_data },
            |m: &mut MimbleWimbleCoinEncryptedSlateData| { &mut m.encrypted_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinEncryptedSlateData>(
            "MimbleWimbleCoinEncryptedSlateData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinEncryptedSlateData {
    const NAME: &'static str = "MimbleWimbleCoinEncryptedSlateData";

    fn is_initialized(&self) -> bool {
        if self.encrypted_data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.encrypted_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encrypted_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encrypted_data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinEncryptedSlateData {
        MimbleWimbleCoinEncryptedSlateData::new()
    }

    fn clear(&mut self) {
        self.encrypted_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinEncryptedSlateData {
        static instance: MimbleWimbleCoinEncryptedSlateData = MimbleWimbleCoinEncryptedSlateData {
            encrypted_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinEncryptedSlateData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinEncryptedSlateData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinEncryptedSlateData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinEncryptedSlateData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishEncryptingSlate)
pub struct MimbleWimbleCoinFinishEncryptingSlate {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishEncryptingSlate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinFinishEncryptingSlate {
    fn default() -> &'a MimbleWimbleCoinFinishEncryptingSlate {
        <MimbleWimbleCoinFinishEncryptingSlate as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinFinishEncryptingSlate {
    pub fn new() -> MimbleWimbleCoinFinishEncryptingSlate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinFinishEncryptingSlate>(
            "MimbleWimbleCoinFinishEncryptingSlate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinFinishEncryptingSlate {
    const NAME: &'static str = "MimbleWimbleCoinFinishEncryptingSlate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinFinishEncryptingSlate {
        MimbleWimbleCoinFinishEncryptingSlate::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinFinishEncryptingSlate {
        static instance: MimbleWimbleCoinFinishEncryptingSlate = MimbleWimbleCoinFinishEncryptingSlate {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinFinishEncryptingSlate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinFinishEncryptingSlate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinFinishEncryptingSlate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinFinishEncryptingSlate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateTagAndSignature)
pub struct MimbleWimbleCoinEncryptedSlateTagAndSignature {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateTagAndSignature.tag)
    pub tag: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateTagAndSignature.mqs_message_signature)
    pub mqs_message_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinEncryptedSlateTagAndSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinEncryptedSlateTagAndSignature {
    fn default() -> &'a MimbleWimbleCoinEncryptedSlateTagAndSignature {
        <MimbleWimbleCoinEncryptedSlateTagAndSignature as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinEncryptedSlateTagAndSignature {
    pub fn new() -> MimbleWimbleCoinEncryptedSlateTagAndSignature {
        ::std::default::Default::default()
    }

    // required bytes tag = 1;

    pub fn tag(&self) -> &[u8] {
        match self.tag.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::vec::Vec<u8>) {
        self.tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tag.is_none() {
            self.tag = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::vec::Vec<u8> {
        self.tag.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mqs_message_signature = 2;

    pub fn mqs_message_signature(&self) -> &[u8] {
        match self.mqs_message_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mqs_message_signature(&mut self) {
        self.mqs_message_signature = ::std::option::Option::None;
    }

    pub fn has_mqs_message_signature(&self) -> bool {
        self.mqs_message_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mqs_message_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.mqs_message_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mqs_message_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mqs_message_signature.is_none() {
            self.mqs_message_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mqs_message_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_mqs_message_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.mqs_message_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &MimbleWimbleCoinEncryptedSlateTagAndSignature| { &m.tag },
            |m: &mut MimbleWimbleCoinEncryptedSlateTagAndSignature| { &mut m.tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mqs_message_signature",
            |m: &MimbleWimbleCoinEncryptedSlateTagAndSignature| { &m.mqs_message_signature },
            |m: &mut MimbleWimbleCoinEncryptedSlateTagAndSignature| { &mut m.mqs_message_signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinEncryptedSlateTagAndSignature>(
            "MimbleWimbleCoinEncryptedSlateTagAndSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinEncryptedSlateTagAndSignature {
    const NAME: &'static str = "MimbleWimbleCoinEncryptedSlateTagAndSignature";

    fn is_initialized(&self) -> bool {
        if self.tag.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.mqs_message_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.mqs_message_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tag.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.mqs_message_signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinEncryptedSlateTagAndSignature {
        MimbleWimbleCoinEncryptedSlateTagAndSignature::new()
    }

    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.mqs_message_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinEncryptedSlateTagAndSignature {
        static instance: MimbleWimbleCoinEncryptedSlateTagAndSignature = MimbleWimbleCoinEncryptedSlateTagAndSignature {
            tag: ::std::option::Option::None,
            mqs_message_signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinEncryptedSlateTagAndSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinEncryptedSlateTagAndSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinEncryptedSlateTagAndSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinEncryptedSlateTagAndSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate)
pub struct MimbleWimbleCoinStartDecryptingSlate {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.nonce)
    pub nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.sender_address_or_ephemeral_x25519_public_key)
    pub sender_address_or_ephemeral_x25519_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.salt_or_encrypted_file_key)
    pub salt_or_encrypted_file_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.payload_nonce)
    pub payload_nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartDecryptingSlate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinStartDecryptingSlate {
    fn default() -> &'a MimbleWimbleCoinStartDecryptingSlate {
        <MimbleWimbleCoinStartDecryptingSlate as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinStartDecryptingSlate {
    pub fn new() -> MimbleWimbleCoinStartDecryptingSlate {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required uint32 index = 4;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // required bytes nonce = 5;

    pub fn nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes sender_address_or_ephemeral_x25519_public_key = 6;

    pub fn sender_address_or_ephemeral_x25519_public_key(&self) -> &[u8] {
        match self.sender_address_or_ephemeral_x25519_public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sender_address_or_ephemeral_x25519_public_key(&mut self) {
        self.sender_address_or_ephemeral_x25519_public_key = ::std::option::Option::None;
    }

    pub fn has_sender_address_or_ephemeral_x25519_public_key(&self) -> bool {
        self.sender_address_or_ephemeral_x25519_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_address_or_ephemeral_x25519_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.sender_address_or_ephemeral_x25519_public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_address_or_ephemeral_x25519_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sender_address_or_ephemeral_x25519_public_key.is_none() {
            self.sender_address_or_ephemeral_x25519_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sender_address_or_ephemeral_x25519_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_address_or_ephemeral_x25519_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.sender_address_or_ephemeral_x25519_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes salt_or_encrypted_file_key = 7;

    pub fn salt_or_encrypted_file_key(&self) -> &[u8] {
        match self.salt_or_encrypted_file_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_salt_or_encrypted_file_key(&mut self) {
        self.salt_or_encrypted_file_key = ::std::option::Option::None;
    }

    pub fn has_salt_or_encrypted_file_key(&self) -> bool {
        self.salt_or_encrypted_file_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt_or_encrypted_file_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt_or_encrypted_file_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt_or_encrypted_file_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt_or_encrypted_file_key.is_none() {
            self.salt_or_encrypted_file_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.salt_or_encrypted_file_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt_or_encrypted_file_key(&mut self) -> ::std::vec::Vec<u8> {
        self.salt_or_encrypted_file_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload_nonce = 8;

    pub fn payload_nonce(&self) -> &[u8] {
        match self.payload_nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload_nonce(&mut self) {
        self.payload_nonce = ::std::option::Option::None;
    }

    pub fn has_payload_nonce(&self) -> bool {
        self.payload_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload_nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload_nonce.is_none() {
            self.payload_nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.payload_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinStartDecryptingSlate| { &m.coin_type },
            |m: &mut MimbleWimbleCoinStartDecryptingSlate| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinStartDecryptingSlate| { &m.network_type },
            |m: &mut MimbleWimbleCoinStartDecryptingSlate| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinStartDecryptingSlate| { &m.account },
            |m: &mut MimbleWimbleCoinStartDecryptingSlate| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &MimbleWimbleCoinStartDecryptingSlate| { &m.index },
            |m: &mut MimbleWimbleCoinStartDecryptingSlate| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nonce",
            |m: &MimbleWimbleCoinStartDecryptingSlate| { &m.nonce },
            |m: &mut MimbleWimbleCoinStartDecryptingSlate| { &mut m.nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_address_or_ephemeral_x25519_public_key",
            |m: &MimbleWimbleCoinStartDecryptingSlate| { &m.sender_address_or_ephemeral_x25519_public_key },
            |m: &mut MimbleWimbleCoinStartDecryptingSlate| { &mut m.sender_address_or_ephemeral_x25519_public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salt_or_encrypted_file_key",
            |m: &MimbleWimbleCoinStartDecryptingSlate| { &m.salt_or_encrypted_file_key },
            |m: &mut MimbleWimbleCoinStartDecryptingSlate| { &mut m.salt_or_encrypted_file_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload_nonce",
            |m: &MimbleWimbleCoinStartDecryptingSlate| { &m.payload_nonce },
            |m: &mut MimbleWimbleCoinStartDecryptingSlate| { &mut m.payload_nonce },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinStartDecryptingSlate>(
            "MimbleWimbleCoinStartDecryptingSlate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinStartDecryptingSlate {
    const NAME: &'static str = "MimbleWimbleCoinStartDecryptingSlate";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        if self.nonce.is_none() {
            return false;
        }
        if self.sender_address_or_ephemeral_x25519_public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.sender_address_or_ephemeral_x25519_public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.salt_or_encrypted_file_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.payload_nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.sender_address_or_ephemeral_x25519_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.salt_or_encrypted_file_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.payload_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.nonce.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.sender_address_or_ephemeral_x25519_public_key.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.salt_or_encrypted_file_key.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.payload_nonce.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinStartDecryptingSlate {
        MimbleWimbleCoinStartDecryptingSlate::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.sender_address_or_ephemeral_x25519_public_key = ::std::option::Option::None;
        self.salt_or_encrypted_file_key = ::std::option::Option::None;
        self.payload_nonce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinStartDecryptingSlate {
        static instance: MimbleWimbleCoinStartDecryptingSlate = MimbleWimbleCoinStartDecryptingSlate {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            index: ::std::option::Option::None,
            nonce: ::std::option::Option::None,
            sender_address_or_ephemeral_x25519_public_key: ::std::option::Option::None,
            salt_or_encrypted_file_key: ::std::option::Option::None,
            payload_nonce: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinStartDecryptingSlate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinStartDecryptingSlate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinStartDecryptingSlate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinStartDecryptingSlate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueDecryptingSlate)
pub struct MimbleWimbleCoinContinueDecryptingSlate {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueDecryptingSlate.encrypted_data)
    pub encrypted_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueDecryptingSlate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinContinueDecryptingSlate {
    fn default() -> &'a MimbleWimbleCoinContinueDecryptingSlate {
        <MimbleWimbleCoinContinueDecryptingSlate as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinContinueDecryptingSlate {
    pub fn new() -> MimbleWimbleCoinContinueDecryptingSlate {
        ::std::default::Default::default()
    }

    // required bytes encrypted_data = 1;

    pub fn encrypted_data(&self) -> &[u8] {
        match self.encrypted_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_data(&mut self) {
        self.encrypted_data = ::std::option::Option::None;
    }

    pub fn has_encrypted_data(&self) -> bool {
        self.encrypted_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_data.is_none() {
            self.encrypted_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encrypted_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_data(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted_data",
            |m: &MimbleWimbleCoinContinueDecryptingSlate| { &m.encrypted_data },
            |m: &mut MimbleWimbleCoinContinueDecryptingSlate| { &mut m.encrypted_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinContinueDecryptingSlate>(
            "MimbleWimbleCoinContinueDecryptingSlate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinContinueDecryptingSlate {
    const NAME: &'static str = "MimbleWimbleCoinContinueDecryptingSlate";

    fn is_initialized(&self) -> bool {
        if self.encrypted_data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.encrypted_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encrypted_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encrypted_data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinContinueDecryptingSlate {
        MimbleWimbleCoinContinueDecryptingSlate::new()
    }

    fn clear(&mut self) {
        self.encrypted_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinContinueDecryptingSlate {
        static instance: MimbleWimbleCoinContinueDecryptingSlate = MimbleWimbleCoinContinueDecryptingSlate {
            encrypted_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinContinueDecryptingSlate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinContinueDecryptingSlate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinContinueDecryptingSlate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinContinueDecryptingSlate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinDecryptedSlateData)
pub struct MimbleWimbleCoinDecryptedSlateData {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinDecryptedSlateData.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinDecryptedSlateData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinDecryptedSlateData {
    fn default() -> &'a MimbleWimbleCoinDecryptedSlateData {
        <MimbleWimbleCoinDecryptedSlateData as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinDecryptedSlateData {
    pub fn new() -> MimbleWimbleCoinDecryptedSlateData {
        ::std::default::Default::default()
    }

    // required bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &MimbleWimbleCoinDecryptedSlateData| { &m.data },
            |m: &mut MimbleWimbleCoinDecryptedSlateData| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinDecryptedSlateData>(
            "MimbleWimbleCoinDecryptedSlateData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinDecryptedSlateData {
    const NAME: &'static str = "MimbleWimbleCoinDecryptedSlateData";

    fn is_initialized(&self) -> bool {
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinDecryptedSlateData {
        MimbleWimbleCoinDecryptedSlateData::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinDecryptedSlateData {
        static instance: MimbleWimbleCoinDecryptedSlateData = MimbleWimbleCoinDecryptedSlateData {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinDecryptedSlateData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinDecryptedSlateData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinDecryptedSlateData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinDecryptedSlateData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishDecryptingSlate)
pub struct MimbleWimbleCoinFinishDecryptingSlate {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishDecryptingSlate.tag)
    pub tag: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishDecryptingSlate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinFinishDecryptingSlate {
    fn default() -> &'a MimbleWimbleCoinFinishDecryptingSlate {
        <MimbleWimbleCoinFinishDecryptingSlate as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinFinishDecryptingSlate {
    pub fn new() -> MimbleWimbleCoinFinishDecryptingSlate {
        ::std::default::Default::default()
    }

    // required bytes tag = 1;

    pub fn tag(&self) -> &[u8] {
        match self.tag.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::vec::Vec<u8>) {
        self.tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tag.is_none() {
            self.tag = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::vec::Vec<u8> {
        self.tag.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &MimbleWimbleCoinFinishDecryptingSlate| { &m.tag },
            |m: &mut MimbleWimbleCoinFinishDecryptingSlate| { &mut m.tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinFinishDecryptingSlate>(
            "MimbleWimbleCoinFinishDecryptingSlate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinFinishDecryptingSlate {
    const NAME: &'static str = "MimbleWimbleCoinFinishDecryptingSlate";

    fn is_initialized(&self) -> bool {
        if self.tag.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tag.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinFinishDecryptingSlate {
        MimbleWimbleCoinFinishDecryptingSlate::new()
    }

    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinFinishDecryptingSlate {
        static instance: MimbleWimbleCoinFinishDecryptingSlate = MimbleWimbleCoinFinishDecryptingSlate {
            tag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinFinishDecryptingSlate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinFinishDecryptingSlate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinFinishDecryptingSlate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinFinishDecryptingSlate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinDecryptedSlateAesKey)
pub struct MimbleWimbleCoinDecryptedSlateAesKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinDecryptedSlateAesKey.aes_key)
    pub aes_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinDecryptedSlateAesKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinDecryptedSlateAesKey {
    fn default() -> &'a MimbleWimbleCoinDecryptedSlateAesKey {
        <MimbleWimbleCoinDecryptedSlateAesKey as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinDecryptedSlateAesKey {
    pub fn new() -> MimbleWimbleCoinDecryptedSlateAesKey {
        ::std::default::Default::default()
    }

    // required bytes aes_key = 1;

    pub fn aes_key(&self) -> &[u8] {
        match self.aes_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_aes_key(&mut self) {
        self.aes_key = ::std::option::Option::None;
    }

    pub fn has_aes_key(&self) -> bool {
        self.aes_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aes_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.aes_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aes_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.aes_key.is_none() {
            self.aes_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.aes_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_aes_key(&mut self) -> ::std::vec::Vec<u8> {
        self.aes_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aes_key",
            |m: &MimbleWimbleCoinDecryptedSlateAesKey| { &m.aes_key },
            |m: &mut MimbleWimbleCoinDecryptedSlateAesKey| { &mut m.aes_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinDecryptedSlateAesKey>(
            "MimbleWimbleCoinDecryptedSlateAesKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinDecryptedSlateAesKey {
    const NAME: &'static str = "MimbleWimbleCoinDecryptedSlateAesKey";

    fn is_initialized(&self) -> bool {
        if self.aes_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.aes_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.aes_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.aes_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinDecryptedSlateAesKey {
        MimbleWimbleCoinDecryptedSlateAesKey::new()
    }

    fn clear(&mut self) {
        self.aes_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinDecryptedSlateAesKey {
        static instance: MimbleWimbleCoinDecryptedSlateAesKey = MimbleWimbleCoinDecryptedSlateAesKey {
            aes_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinDecryptedSlateAesKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinDecryptedSlateAesKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinDecryptedSlateAesKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinDecryptedSlateAesKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction)
pub struct MimbleWimbleCoinStartTransaction {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.output)
    pub output: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.input)
    pub input: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.fee)
    pub fee: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.secret_nonce_index)
    pub secret_nonce_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.address)
    pub address: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinStartTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinStartTransaction {
    fn default() -> &'a MimbleWimbleCoinStartTransaction {
        <MimbleWimbleCoinStartTransaction as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinStartTransaction {
    pub fn new() -> MimbleWimbleCoinStartTransaction {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required uint32 index = 4;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // required uint64 output = 5;

    pub fn output(&self) -> u64 {
        self.output.unwrap_or(0)
    }

    pub fn clear_output(&mut self) {
        self.output = ::std::option::Option::None;
    }

    pub fn has_output(&self) -> bool {
        self.output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: u64) {
        self.output = ::std::option::Option::Some(v);
    }

    // required uint64 input = 6;

    pub fn input(&self) -> u64 {
        self.input.unwrap_or(0)
    }

    pub fn clear_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: u64) {
        self.input = ::std::option::Option::Some(v);
    }

    // required uint64 fee = 7;

    pub fn fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }

    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // required uint32 secret_nonce_index = 8;

    pub fn secret_nonce_index(&self) -> u32 {
        self.secret_nonce_index.unwrap_or(0)
    }

    pub fn clear_secret_nonce_index(&mut self) {
        self.secret_nonce_index = ::std::option::Option::None;
    }

    pub fn has_secret_nonce_index(&self) -> bool {
        self.secret_nonce_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret_nonce_index(&mut self, v: u32) {
        self.secret_nonce_index = ::std::option::Option::Some(v);
    }

    // optional bytes address = 9;

    pub fn address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinStartTransaction| { &m.coin_type },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinStartTransaction| { &m.network_type },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinStartTransaction| { &m.account },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &MimbleWimbleCoinStartTransaction| { &m.index },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "output",
            |m: &MimbleWimbleCoinStartTransaction| { &m.output },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "input",
            |m: &MimbleWimbleCoinStartTransaction| { &m.input },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fee",
            |m: &MimbleWimbleCoinStartTransaction| { &m.fee },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.fee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secret_nonce_index",
            |m: &MimbleWimbleCoinStartTransaction| { &m.secret_nonce_index },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.secret_nonce_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &MimbleWimbleCoinStartTransaction| { &m.address },
            |m: &mut MimbleWimbleCoinStartTransaction| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinStartTransaction>(
            "MimbleWimbleCoinStartTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinStartTransaction {
    const NAME: &'static str = "MimbleWimbleCoinStartTransaction";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        if self.output.is_none() {
            return false;
        }
        if self.input.is_none() {
            return false;
        }
        if self.fee.is_none() {
            return false;
        }
        if self.secret_nonce_index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.output = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.input = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.fee = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.secret_nonce_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.address = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.output {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.input {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.secret_nonce_index {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.output {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.input {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.secret_nonce_index {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            os.write_bytes(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinStartTransaction {
        MimbleWimbleCoinStartTransaction::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.output = ::std::option::Option::None;
        self.input = ::std::option::Option::None;
        self.fee = ::std::option::Option::None;
        self.secret_nonce_index = ::std::option::Option::None;
        self.address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinStartTransaction {
        static instance: MimbleWimbleCoinStartTransaction = MimbleWimbleCoinStartTransaction {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            index: ::std::option::Option::None,
            output: ::std::option::Option::None,
            input: ::std::option::Option::None,
            fee: ::std::option::Option::None,
            secret_nonce_index: ::std::option::Option::None,
            address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinStartTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinStartTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinStartTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinStartTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeOutput)
pub struct MimbleWimbleCoinContinueTransactionIncludeOutput {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeOutput.identifier)
    pub identifier: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeOutput.value)
    pub value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeOutput.switch_type)
    pub switch_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinSwitchType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeOutput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinContinueTransactionIncludeOutput {
    fn default() -> &'a MimbleWimbleCoinContinueTransactionIncludeOutput {
        <MimbleWimbleCoinContinueTransactionIncludeOutput as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinContinueTransactionIncludeOutput {
    pub fn new() -> MimbleWimbleCoinContinueTransactionIncludeOutput {
        ::std::default::Default::default()
    }

    // required bytes identifier = 1;

    pub fn identifier(&self) -> &[u8] {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::vec::Vec<u8> {
        self.identifier.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 value = 2;

    pub fn value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchType switch_type = 3;

    pub fn switch_type(&self) -> MimbleWimbleCoinSwitchType {
        match self.switch_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinSwitchType::NONE),
            None => MimbleWimbleCoinSwitchType::NONE,
        }
    }

    pub fn clear_switch_type(&mut self) {
        self.switch_type = ::std::option::Option::None;
    }

    pub fn has_switch_type(&self) -> bool {
        self.switch_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_switch_type(&mut self, v: MimbleWimbleCoinSwitchType) {
        self.switch_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &MimbleWimbleCoinContinueTransactionIncludeOutput| { &m.identifier },
            |m: &mut MimbleWimbleCoinContinueTransactionIncludeOutput| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &MimbleWimbleCoinContinueTransactionIncludeOutput| { &m.value },
            |m: &mut MimbleWimbleCoinContinueTransactionIncludeOutput| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "switch_type",
            |m: &MimbleWimbleCoinContinueTransactionIncludeOutput| { &m.switch_type },
            |m: &mut MimbleWimbleCoinContinueTransactionIncludeOutput| { &mut m.switch_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinContinueTransactionIncludeOutput>(
            "MimbleWimbleCoinContinueTransactionIncludeOutput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinContinueTransactionIncludeOutput {
    const NAME: &'static str = "MimbleWimbleCoinContinueTransactionIncludeOutput";

    fn is_initialized(&self) -> bool {
        if self.identifier.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        if self.switch_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.identifier = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.switch_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.switch_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identifier.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.switch_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinContinueTransactionIncludeOutput {
        MimbleWimbleCoinContinueTransactionIncludeOutput::new()
    }

    fn clear(&mut self) {
        self.identifier = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.switch_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinContinueTransactionIncludeOutput {
        static instance: MimbleWimbleCoinContinueTransactionIncludeOutput = MimbleWimbleCoinContinueTransactionIncludeOutput {
            identifier: ::std::option::Option::None,
            value: ::std::option::Option::None,
            switch_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinContinueTransactionIncludeOutput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinContinueTransactionIncludeOutput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinContinueTransactionIncludeOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinContinueTransactionIncludeOutput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeInput)
pub struct MimbleWimbleCoinContinueTransactionIncludeInput {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeInput.identifier)
    pub identifier: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeInput.value)
    pub value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeInput.switch_type)
    pub switch_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinSwitchType>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionIncludeInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinContinueTransactionIncludeInput {
    fn default() -> &'a MimbleWimbleCoinContinueTransactionIncludeInput {
        <MimbleWimbleCoinContinueTransactionIncludeInput as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinContinueTransactionIncludeInput {
    pub fn new() -> MimbleWimbleCoinContinueTransactionIncludeInput {
        ::std::default::Default::default()
    }

    // required bytes identifier = 1;

    pub fn identifier(&self) -> &[u8] {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::vec::Vec<u8> {
        self.identifier.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 value = 2;

    pub fn value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchType switch_type = 3;

    pub fn switch_type(&self) -> MimbleWimbleCoinSwitchType {
        match self.switch_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinSwitchType::NONE),
            None => MimbleWimbleCoinSwitchType::NONE,
        }
    }

    pub fn clear_switch_type(&mut self) {
        self.switch_type = ::std::option::Option::None;
    }

    pub fn has_switch_type(&self) -> bool {
        self.switch_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_switch_type(&mut self, v: MimbleWimbleCoinSwitchType) {
        self.switch_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &MimbleWimbleCoinContinueTransactionIncludeInput| { &m.identifier },
            |m: &mut MimbleWimbleCoinContinueTransactionIncludeInput| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &MimbleWimbleCoinContinueTransactionIncludeInput| { &m.value },
            |m: &mut MimbleWimbleCoinContinueTransactionIncludeInput| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "switch_type",
            |m: &MimbleWimbleCoinContinueTransactionIncludeInput| { &m.switch_type },
            |m: &mut MimbleWimbleCoinContinueTransactionIncludeInput| { &mut m.switch_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinContinueTransactionIncludeInput>(
            "MimbleWimbleCoinContinueTransactionIncludeInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinContinueTransactionIncludeInput {
    const NAME: &'static str = "MimbleWimbleCoinContinueTransactionIncludeInput";

    fn is_initialized(&self) -> bool {
        if self.identifier.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        if self.switch_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.identifier = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.switch_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.switch_type {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identifier.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.switch_type {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinContinueTransactionIncludeInput {
        MimbleWimbleCoinContinueTransactionIncludeInput::new()
    }

    fn clear(&mut self) {
        self.identifier = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.switch_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinContinueTransactionIncludeInput {
        static instance: MimbleWimbleCoinContinueTransactionIncludeInput = MimbleWimbleCoinContinueTransactionIncludeInput {
            identifier: ::std::option::Option::None,
            value: ::std::option::Option::None,
            switch_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinContinueTransactionIncludeInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinContinueTransactionIncludeInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinContinueTransactionIncludeInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinContinueTransactionIncludeInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionApplyOffset)
pub struct MimbleWimbleCoinContinueTransactionApplyOffset {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionApplyOffset.offset)
    pub offset: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionApplyOffset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinContinueTransactionApplyOffset {
    fn default() -> &'a MimbleWimbleCoinContinueTransactionApplyOffset {
        <MimbleWimbleCoinContinueTransactionApplyOffset as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinContinueTransactionApplyOffset {
    pub fn new() -> MimbleWimbleCoinContinueTransactionApplyOffset {
        ::std::default::Default::default()
    }

    // required bytes offset = 1;

    pub fn offset(&self) -> &[u8] {
        match self.offset.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: ::std::vec::Vec<u8>) {
        self.offset = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offset(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.offset.is_none() {
            self.offset = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_offset(&mut self) -> ::std::vec::Vec<u8> {
        self.offset.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &MimbleWimbleCoinContinueTransactionApplyOffset| { &m.offset },
            |m: &mut MimbleWimbleCoinContinueTransactionApplyOffset| { &mut m.offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinContinueTransactionApplyOffset>(
            "MimbleWimbleCoinContinueTransactionApplyOffset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinContinueTransactionApplyOffset {
    const NAME: &'static str = "MimbleWimbleCoinContinueTransactionApplyOffset";

    fn is_initialized(&self) -> bool {
        if self.offset.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.offset = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.offset.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.offset.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinContinueTransactionApplyOffset {
        MimbleWimbleCoinContinueTransactionApplyOffset::new()
    }

    fn clear(&mut self) {
        self.offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinContinueTransactionApplyOffset {
        static instance: MimbleWimbleCoinContinueTransactionApplyOffset = MimbleWimbleCoinContinueTransactionApplyOffset {
            offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinContinueTransactionApplyOffset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinContinueTransactionApplyOffset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinContinueTransactionApplyOffset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinContinueTransactionApplyOffset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionSecretNonceIndex)
pub struct MimbleWimbleCoinTransactionSecretNonceIndex {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionSecretNonceIndex.secret_nonce_index)
    pub secret_nonce_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionSecretNonceIndex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinTransactionSecretNonceIndex {
    fn default() -> &'a MimbleWimbleCoinTransactionSecretNonceIndex {
        <MimbleWimbleCoinTransactionSecretNonceIndex as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinTransactionSecretNonceIndex {
    pub fn new() -> MimbleWimbleCoinTransactionSecretNonceIndex {
        ::std::default::Default::default()
    }

    // optional uint32 secret_nonce_index = 1;

    pub fn secret_nonce_index(&self) -> u32 {
        self.secret_nonce_index.unwrap_or(0)
    }

    pub fn clear_secret_nonce_index(&mut self) {
        self.secret_nonce_index = ::std::option::Option::None;
    }

    pub fn has_secret_nonce_index(&self) -> bool {
        self.secret_nonce_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret_nonce_index(&mut self, v: u32) {
        self.secret_nonce_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secret_nonce_index",
            |m: &MimbleWimbleCoinTransactionSecretNonceIndex| { &m.secret_nonce_index },
            |m: &mut MimbleWimbleCoinTransactionSecretNonceIndex| { &mut m.secret_nonce_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinTransactionSecretNonceIndex>(
            "MimbleWimbleCoinTransactionSecretNonceIndex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinTransactionSecretNonceIndex {
    const NAME: &'static str = "MimbleWimbleCoinTransactionSecretNonceIndex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.secret_nonce_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.secret_nonce_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.secret_nonce_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinTransactionSecretNonceIndex {
        MimbleWimbleCoinTransactionSecretNonceIndex::new()
    }

    fn clear(&mut self) {
        self.secret_nonce_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinTransactionSecretNonceIndex {
        static instance: MimbleWimbleCoinTransactionSecretNonceIndex = MimbleWimbleCoinTransactionSecretNonceIndex {
            secret_nonce_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinTransactionSecretNonceIndex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinTransactionSecretNonceIndex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinTransactionSecretNonceIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinTransactionSecretNonceIndex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionGetPublicKey)
pub struct MimbleWimbleCoinContinueTransactionGetPublicKey {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionGetPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinContinueTransactionGetPublicKey {
    fn default() -> &'a MimbleWimbleCoinContinueTransactionGetPublicKey {
        <MimbleWimbleCoinContinueTransactionGetPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinContinueTransactionGetPublicKey {
    pub fn new() -> MimbleWimbleCoinContinueTransactionGetPublicKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinContinueTransactionGetPublicKey>(
            "MimbleWimbleCoinContinueTransactionGetPublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinContinueTransactionGetPublicKey {
    const NAME: &'static str = "MimbleWimbleCoinContinueTransactionGetPublicKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinContinueTransactionGetPublicKey {
        MimbleWimbleCoinContinueTransactionGetPublicKey::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinContinueTransactionGetPublicKey {
        static instance: MimbleWimbleCoinContinueTransactionGetPublicKey = MimbleWimbleCoinContinueTransactionGetPublicKey {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinContinueTransactionGetPublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinContinueTransactionGetPublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinContinueTransactionGetPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinContinueTransactionGetPublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionPublicKey)
pub struct MimbleWimbleCoinTransactionPublicKey {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionPublicKey.public_key)
    pub public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionPublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinTransactionPublicKey {
    fn default() -> &'a MimbleWimbleCoinTransactionPublicKey {
        <MimbleWimbleCoinTransactionPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinTransactionPublicKey {
    pub fn new() -> MimbleWimbleCoinTransactionPublicKey {
        ::std::default::Default::default()
    }

    // required bytes public_key = 1;

    pub fn public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_key(&mut self) {
        self.public_key = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_key",
            |m: &MimbleWimbleCoinTransactionPublicKey| { &m.public_key },
            |m: &mut MimbleWimbleCoinTransactionPublicKey| { &mut m.public_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinTransactionPublicKey>(
            "MimbleWimbleCoinTransactionPublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinTransactionPublicKey {
    const NAME: &'static str = "MimbleWimbleCoinTransactionPublicKey";

    fn is_initialized(&self) -> bool {
        if self.public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.public_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinTransactionPublicKey {
        MimbleWimbleCoinTransactionPublicKey::new()
    }

    fn clear(&mut self) {
        self.public_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinTransactionPublicKey {
        static instance: MimbleWimbleCoinTransactionPublicKey = MimbleWimbleCoinTransactionPublicKey {
            public_key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinTransactionPublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinTransactionPublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinTransactionPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinTransactionPublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionGetPublicNonce)
pub struct MimbleWimbleCoinContinueTransactionGetPublicNonce {
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionGetPublicNonce.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinContinueTransactionGetPublicNonce {
    fn default() -> &'a MimbleWimbleCoinContinueTransactionGetPublicNonce {
        <MimbleWimbleCoinContinueTransactionGetPublicNonce as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinContinueTransactionGetPublicNonce {
    pub fn new() -> MimbleWimbleCoinContinueTransactionGetPublicNonce {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinContinueTransactionGetPublicNonce>(
            "MimbleWimbleCoinContinueTransactionGetPublicNonce",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinContinueTransactionGetPublicNonce {
    const NAME: &'static str = "MimbleWimbleCoinContinueTransactionGetPublicNonce";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinContinueTransactionGetPublicNonce {
        MimbleWimbleCoinContinueTransactionGetPublicNonce::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinContinueTransactionGetPublicNonce {
        static instance: MimbleWimbleCoinContinueTransactionGetPublicNonce = MimbleWimbleCoinContinueTransactionGetPublicNonce {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinContinueTransactionGetPublicNonce {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinContinueTransactionGetPublicNonce").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinContinueTransactionGetPublicNonce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinContinueTransactionGetPublicNonce {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionPublicNonce)
pub struct MimbleWimbleCoinTransactionPublicNonce {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionPublicNonce.public_nonce)
    pub public_nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionPublicNonce.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinTransactionPublicNonce {
    fn default() -> &'a MimbleWimbleCoinTransactionPublicNonce {
        <MimbleWimbleCoinTransactionPublicNonce as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinTransactionPublicNonce {
    pub fn new() -> MimbleWimbleCoinTransactionPublicNonce {
        ::std::default::Default::default()
    }

    // required bytes public_nonce = 1;

    pub fn public_nonce(&self) -> &[u8] {
        match self.public_nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_nonce(&mut self) {
        self.public_nonce = ::std::option::Option::None;
    }

    pub fn has_public_nonce(&self) -> bool {
        self.public_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_nonce.is_none() {
            self.public_nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.public_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_nonce",
            |m: &MimbleWimbleCoinTransactionPublicNonce| { &m.public_nonce },
            |m: &mut MimbleWimbleCoinTransactionPublicNonce| { &mut m.public_nonce },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinTransactionPublicNonce>(
            "MimbleWimbleCoinTransactionPublicNonce",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinTransactionPublicNonce {
    const NAME: &'static str = "MimbleWimbleCoinTransactionPublicNonce";

    fn is_initialized(&self) -> bool {
        if self.public_nonce.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.public_nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.public_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.public_nonce.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinTransactionPublicNonce {
        MimbleWimbleCoinTransactionPublicNonce::new()
    }

    fn clear(&mut self) {
        self.public_nonce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinTransactionPublicNonce {
        static instance: MimbleWimbleCoinTransactionPublicNonce = MimbleWimbleCoinTransactionPublicNonce {
            public_nonce: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinTransactionPublicNonce {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinTransactionPublicNonce").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinTransactionPublicNonce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinTransactionPublicNonce {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionGetMessageSignature)
pub struct MimbleWimbleCoinContinueTransactionGetMessageSignature {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionGetMessageSignature.message)
    pub message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinContinueTransactionGetMessageSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinContinueTransactionGetMessageSignature {
    fn default() -> &'a MimbleWimbleCoinContinueTransactionGetMessageSignature {
        <MimbleWimbleCoinContinueTransactionGetMessageSignature as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinContinueTransactionGetMessageSignature {
    pub fn new() -> MimbleWimbleCoinContinueTransactionGetMessageSignature {
        ::std::default::Default::default()
    }

    // required bytes message = 1;

    pub fn message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &MimbleWimbleCoinContinueTransactionGetMessageSignature| { &m.message },
            |m: &mut MimbleWimbleCoinContinueTransactionGetMessageSignature| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinContinueTransactionGetMessageSignature>(
            "MimbleWimbleCoinContinueTransactionGetMessageSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinContinueTransactionGetMessageSignature {
    const NAME: &'static str = "MimbleWimbleCoinContinueTransactionGetMessageSignature";

    fn is_initialized(&self) -> bool {
        if self.message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinContinueTransactionGetMessageSignature {
        MimbleWimbleCoinContinueTransactionGetMessageSignature::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinContinueTransactionGetMessageSignature {
        static instance: MimbleWimbleCoinContinueTransactionGetMessageSignature = MimbleWimbleCoinContinueTransactionGetMessageSignature {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinContinueTransactionGetMessageSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinContinueTransactionGetMessageSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinContinueTransactionGetMessageSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinContinueTransactionGetMessageSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionMessageSignature)
pub struct MimbleWimbleCoinTransactionMessageSignature {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionMessageSignature.message_signature)
    pub message_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionMessageSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinTransactionMessageSignature {
    fn default() -> &'a MimbleWimbleCoinTransactionMessageSignature {
        <MimbleWimbleCoinTransactionMessageSignature as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinTransactionMessageSignature {
    pub fn new() -> MimbleWimbleCoinTransactionMessageSignature {
        ::std::default::Default::default()
    }

    // required bytes message_signature = 1;

    pub fn message_signature(&self) -> &[u8] {
        match self.message_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_signature(&mut self) {
        self.message_signature = ::std::option::Option::None;
    }

    pub fn has_message_signature(&self) -> bool {
        self.message_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_signature.is_none() {
            self.message_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.message_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_signature",
            |m: &MimbleWimbleCoinTransactionMessageSignature| { &m.message_signature },
            |m: &mut MimbleWimbleCoinTransactionMessageSignature| { &mut m.message_signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinTransactionMessageSignature>(
            "MimbleWimbleCoinTransactionMessageSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinTransactionMessageSignature {
    const NAME: &'static str = "MimbleWimbleCoinTransactionMessageSignature";

    fn is_initialized(&self) -> bool {
        if self.message_signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_signature.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinTransactionMessageSignature {
        MimbleWimbleCoinTransactionMessageSignature::new()
    }

    fn clear(&mut self) {
        self.message_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinTransactionMessageSignature {
        static instance: MimbleWimbleCoinTransactionMessageSignature = MimbleWimbleCoinTransactionMessageSignature {
            message_signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinTransactionMessageSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinTransactionMessageSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinTransactionMessageSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinTransactionMessageSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishTransaction)
pub struct MimbleWimbleCoinFinishTransaction {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishTransaction.address_type)
    pub address_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinAddressType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishTransaction.public_nonce)
    pub public_nonce: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishTransaction.public_key)
    pub public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishTransaction.kernel_information)
    pub kernel_information: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishTransaction.kernel_commitment)
    pub kernel_commitment: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishTransaction.payment_proof)
    pub payment_proof: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinFinishTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinFinishTransaction {
    fn default() -> &'a MimbleWimbleCoinFinishTransaction {
        <MimbleWimbleCoinFinishTransaction as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinFinishTransaction {
    pub fn new() -> MimbleWimbleCoinFinishTransaction {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddressType address_type = 1;

    pub fn address_type(&self) -> MimbleWimbleCoinAddressType {
        match self.address_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinAddressType::MQS),
            None => MimbleWimbleCoinAddressType::MQS,
        }
    }

    pub fn clear_address_type(&mut self) {
        self.address_type = ::std::option::Option::None;
    }

    pub fn has_address_type(&self) -> bool {
        self.address_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address_type(&mut self, v: MimbleWimbleCoinAddressType) {
        self.address_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required bytes public_nonce = 2;

    pub fn public_nonce(&self) -> &[u8] {
        match self.public_nonce.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_nonce(&mut self) {
        self.public_nonce = ::std::option::Option::None;
    }

    pub fn has_public_nonce(&self) -> bool {
        self.public_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_nonce = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_nonce.is_none() {
            self.public_nonce = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.public_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes public_key = 3;

    pub fn public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_public_key(&mut self) {
        self.public_key = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes kernel_information = 4;

    pub fn kernel_information(&self) -> &[u8] {
        match self.kernel_information.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_kernel_information(&mut self) {
        self.kernel_information = ::std::option::Option::None;
    }

    pub fn has_kernel_information(&self) -> bool {
        self.kernel_information.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel_information(&mut self, v: ::std::vec::Vec<u8>) {
        self.kernel_information = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel_information(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kernel_information.is_none() {
            self.kernel_information = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.kernel_information.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernel_information(&mut self) -> ::std::vec::Vec<u8> {
        self.kernel_information.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes kernel_commitment = 5;

    pub fn kernel_commitment(&self) -> &[u8] {
        match self.kernel_commitment.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_kernel_commitment(&mut self) {
        self.kernel_commitment = ::std::option::Option::None;
    }

    pub fn has_kernel_commitment(&self) -> bool {
        self.kernel_commitment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernel_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.kernel_commitment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kernel_commitment.is_none() {
            self.kernel_commitment = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.kernel_commitment.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernel_commitment(&mut self) -> ::std::vec::Vec<u8> {
        self.kernel_commitment.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payment_proof = 6;

    pub fn payment_proof(&self) -> &[u8] {
        match self.payment_proof.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payment_proof(&mut self) {
        self.payment_proof = ::std::option::Option::None;
    }

    pub fn has_payment_proof(&self) -> bool {
        self.payment_proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_proof = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payment_proof.is_none() {
            self.payment_proof = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payment_proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_proof(&mut self) -> ::std::vec::Vec<u8> {
        self.payment_proof.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address_type",
            |m: &MimbleWimbleCoinFinishTransaction| { &m.address_type },
            |m: &mut MimbleWimbleCoinFinishTransaction| { &mut m.address_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_nonce",
            |m: &MimbleWimbleCoinFinishTransaction| { &m.public_nonce },
            |m: &mut MimbleWimbleCoinFinishTransaction| { &mut m.public_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_key",
            |m: &MimbleWimbleCoinFinishTransaction| { &m.public_key },
            |m: &mut MimbleWimbleCoinFinishTransaction| { &mut m.public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kernel_information",
            |m: &MimbleWimbleCoinFinishTransaction| { &m.kernel_information },
            |m: &mut MimbleWimbleCoinFinishTransaction| { &mut m.kernel_information },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kernel_commitment",
            |m: &MimbleWimbleCoinFinishTransaction| { &m.kernel_commitment },
            |m: &mut MimbleWimbleCoinFinishTransaction| { &mut m.kernel_commitment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payment_proof",
            |m: &MimbleWimbleCoinFinishTransaction| { &m.payment_proof },
            |m: &mut MimbleWimbleCoinFinishTransaction| { &mut m.payment_proof },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinFinishTransaction>(
            "MimbleWimbleCoinFinishTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinFinishTransaction {
    const NAME: &'static str = "MimbleWimbleCoinFinishTransaction";

    fn is_initialized(&self) -> bool {
        if self.address_type.is_none() {
            return false;
        }
        if self.public_nonce.is_none() {
            return false;
        }
        if self.public_key.is_none() {
            return false;
        }
        if self.kernel_information.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.public_nonce = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.kernel_information = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.kernel_commitment = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.payment_proof = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.address_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.public_nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.kernel_information.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.kernel_commitment.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.payment_proof.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.address_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.public_nonce.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.public_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.kernel_information.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.kernel_commitment.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.payment_proof.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinFinishTransaction {
        MimbleWimbleCoinFinishTransaction::new()
    }

    fn clear(&mut self) {
        self.address_type = ::std::option::Option::None;
        self.public_nonce = ::std::option::Option::None;
        self.public_key = ::std::option::Option::None;
        self.kernel_information = ::std::option::Option::None;
        self.kernel_commitment = ::std::option::Option::None;
        self.payment_proof = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinFinishTransaction {
        static instance: MimbleWimbleCoinFinishTransaction = MimbleWimbleCoinFinishTransaction {
            address_type: ::std::option::Option::None,
            public_nonce: ::std::option::Option::None,
            public_key: ::std::option::Option::None,
            kernel_information: ::std::option::Option::None,
            kernel_commitment: ::std::option::Option::None,
            payment_proof: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinFinishTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinFinishTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinFinishTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinFinishTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionSignatureAndPaymentProof)
pub struct MimbleWimbleCoinTransactionSignatureAndPaymentProof {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionSignatureAndPaymentProof.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionSignatureAndPaymentProof.payment_proof)
    pub payment_proof: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinTransactionSignatureAndPaymentProof.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinTransactionSignatureAndPaymentProof {
    fn default() -> &'a MimbleWimbleCoinTransactionSignatureAndPaymentProof {
        <MimbleWimbleCoinTransactionSignatureAndPaymentProof as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinTransactionSignatureAndPaymentProof {
    pub fn new() -> MimbleWimbleCoinTransactionSignatureAndPaymentProof {
        ::std::default::Default::default()
    }

    // required bytes signature = 1;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payment_proof = 2;

    pub fn payment_proof(&self) -> &[u8] {
        match self.payment_proof.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payment_proof(&mut self) {
        self.payment_proof = ::std::option::Option::None;
    }

    pub fn has_payment_proof(&self) -> bool {
        self.payment_proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_proof(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_proof = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_proof(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payment_proof.is_none() {
            self.payment_proof = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payment_proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_proof(&mut self) -> ::std::vec::Vec<u8> {
        self.payment_proof.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &MimbleWimbleCoinTransactionSignatureAndPaymentProof| { &m.signature },
            |m: &mut MimbleWimbleCoinTransactionSignatureAndPaymentProof| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payment_proof",
            |m: &MimbleWimbleCoinTransactionSignatureAndPaymentProof| { &m.payment_proof },
            |m: &mut MimbleWimbleCoinTransactionSignatureAndPaymentProof| { &mut m.payment_proof },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinTransactionSignatureAndPaymentProof>(
            "MimbleWimbleCoinTransactionSignatureAndPaymentProof",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinTransactionSignatureAndPaymentProof {
    const NAME: &'static str = "MimbleWimbleCoinTransactionSignatureAndPaymentProof";

    fn is_initialized(&self) -> bool {
        if self.signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.payment_proof = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.payment_proof.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.payment_proof.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinTransactionSignatureAndPaymentProof {
        MimbleWimbleCoinTransactionSignatureAndPaymentProof::new()
    }

    fn clear(&mut self) {
        self.signature = ::std::option::Option::None;
        self.payment_proof = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinTransactionSignatureAndPaymentProof {
        static instance: MimbleWimbleCoinTransactionSignatureAndPaymentProof = MimbleWimbleCoinTransactionSignatureAndPaymentProof {
            signature: ::std::option::Option::None,
            payment_proof: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinTransactionSignatureAndPaymentProof {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinTransactionSignatureAndPaymentProof").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinTransactionSignatureAndPaymentProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinTransactionSignatureAndPaymentProof {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetMqsChallengeSignature)
pub struct MimbleWimbleCoinGetMqsChallengeSignature {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetMqsChallengeSignature.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetMqsChallengeSignature.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetMqsChallengeSignature.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetMqsChallengeSignature.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetMqsChallengeSignature.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetMqsChallengeSignature.time_zone_offset)
    pub time_zone_offset: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetMqsChallengeSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinGetMqsChallengeSignature {
    fn default() -> &'a MimbleWimbleCoinGetMqsChallengeSignature {
        <MimbleWimbleCoinGetMqsChallengeSignature as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinGetMqsChallengeSignature {
    pub fn new() -> MimbleWimbleCoinGetMqsChallengeSignature {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required uint32 index = 4;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional uint64 timestamp = 5;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional sint32 time_zone_offset = 6;

    pub fn time_zone_offset(&self) -> i32 {
        self.time_zone_offset.unwrap_or(0)
    }

    pub fn clear_time_zone_offset(&mut self) {
        self.time_zone_offset = ::std::option::Option::None;
    }

    pub fn has_time_zone_offset(&self) -> bool {
        self.time_zone_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_zone_offset(&mut self, v: i32) {
        self.time_zone_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinGetMqsChallengeSignature| { &m.coin_type },
            |m: &mut MimbleWimbleCoinGetMqsChallengeSignature| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinGetMqsChallengeSignature| { &m.network_type },
            |m: &mut MimbleWimbleCoinGetMqsChallengeSignature| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinGetMqsChallengeSignature| { &m.account },
            |m: &mut MimbleWimbleCoinGetMqsChallengeSignature| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &MimbleWimbleCoinGetMqsChallengeSignature| { &m.index },
            |m: &mut MimbleWimbleCoinGetMqsChallengeSignature| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &MimbleWimbleCoinGetMqsChallengeSignature| { &m.timestamp },
            |m: &mut MimbleWimbleCoinGetMqsChallengeSignature| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_zone_offset",
            |m: &MimbleWimbleCoinGetMqsChallengeSignature| { &m.time_zone_offset },
            |m: &mut MimbleWimbleCoinGetMqsChallengeSignature| { &mut m.time_zone_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinGetMqsChallengeSignature>(
            "MimbleWimbleCoinGetMqsChallengeSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinGetMqsChallengeSignature {
    const NAME: &'static str = "MimbleWimbleCoinGetMqsChallengeSignature";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.time_zone_offset = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.time_zone_offset {
            my_size += ::protobuf::rt::sint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.time_zone_offset {
            os.write_sint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinGetMqsChallengeSignature {
        MimbleWimbleCoinGetMqsChallengeSignature::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.time_zone_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinGetMqsChallengeSignature {
        static instance: MimbleWimbleCoinGetMqsChallengeSignature = MimbleWimbleCoinGetMqsChallengeSignature {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            index: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            time_zone_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinGetMqsChallengeSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinGetMqsChallengeSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinGetMqsChallengeSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinGetMqsChallengeSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinMqsChallengeSignature)
pub struct MimbleWimbleCoinMqsChallengeSignature {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinMqsChallengeSignature.mqs_challenge_signature)
    pub mqs_challenge_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinMqsChallengeSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinMqsChallengeSignature {
    fn default() -> &'a MimbleWimbleCoinMqsChallengeSignature {
        <MimbleWimbleCoinMqsChallengeSignature as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinMqsChallengeSignature {
    pub fn new() -> MimbleWimbleCoinMqsChallengeSignature {
        ::std::default::Default::default()
    }

    // required bytes mqs_challenge_signature = 1;

    pub fn mqs_challenge_signature(&self) -> &[u8] {
        match self.mqs_challenge_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mqs_challenge_signature(&mut self) {
        self.mqs_challenge_signature = ::std::option::Option::None;
    }

    pub fn has_mqs_challenge_signature(&self) -> bool {
        self.mqs_challenge_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mqs_challenge_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.mqs_challenge_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mqs_challenge_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mqs_challenge_signature.is_none() {
            self.mqs_challenge_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mqs_challenge_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_mqs_challenge_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.mqs_challenge_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mqs_challenge_signature",
            |m: &MimbleWimbleCoinMqsChallengeSignature| { &m.mqs_challenge_signature },
            |m: &mut MimbleWimbleCoinMqsChallengeSignature| { &mut m.mqs_challenge_signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinMqsChallengeSignature>(
            "MimbleWimbleCoinMqsChallengeSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinMqsChallengeSignature {
    const NAME: &'static str = "MimbleWimbleCoinMqsChallengeSignature";

    fn is_initialized(&self) -> bool {
        if self.mqs_challenge_signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mqs_challenge_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mqs_challenge_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mqs_challenge_signature.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinMqsChallengeSignature {
        MimbleWimbleCoinMqsChallengeSignature::new()
    }

    fn clear(&mut self) {
        self.mqs_challenge_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinMqsChallengeSignature {
        static instance: MimbleWimbleCoinMqsChallengeSignature = MimbleWimbleCoinMqsChallengeSignature {
            mqs_challenge_signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinMqsChallengeSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinMqsChallengeSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinMqsChallengeSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinMqsChallengeSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetLoginChallengeSignature)
pub struct MimbleWimbleCoinGetLoginChallengeSignature {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetLoginChallengeSignature.coin_type)
    pub coin_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinCoinType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetLoginChallengeSignature.network_type)
    pub network_type: ::std::option::Option<::protobuf::EnumOrUnknown<MimbleWimbleCoinNetworkType>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetLoginChallengeSignature.account)
    pub account: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetLoginChallengeSignature.identifier)
    pub identifier: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetLoginChallengeSignature.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetLoginChallengeSignature.time_zone_offset)
    pub time_zone_offset: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinGetLoginChallengeSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinGetLoginChallengeSignature {
    fn default() -> &'a MimbleWimbleCoinGetLoginChallengeSignature {
        <MimbleWimbleCoinGetLoginChallengeSignature as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinGetLoginChallengeSignature {
    pub fn new() -> MimbleWimbleCoinGetLoginChallengeSignature {
        ::std::default::Default::default()
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType coin_type = 1;

    pub fn coin_type(&self) -> MimbleWimbleCoinCoinType {
        match self.coin_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            None => MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        }
    }

    pub fn clear_coin_type(&mut self) {
        self.coin_type = ::std::option::Option::None;
    }

    pub fn has_coin_type(&self) -> bool {
        self.coin_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coin_type(&mut self, v: MimbleWimbleCoinCoinType) {
        self.coin_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType network_type = 2;

    pub fn network_type(&self) -> MimbleWimbleCoinNetworkType {
        match self.network_type {
            Some(e) => e.enum_value_or(MimbleWimbleCoinNetworkType::MAINNET),
            None => MimbleWimbleCoinNetworkType::MAINNET,
        }
    }

    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: MimbleWimbleCoinNetworkType) {
        self.network_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 account = 3;

    pub fn account(&self) -> u32 {
        self.account.unwrap_or(0)
    }

    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // required bytes identifier = 4;

    pub fn identifier(&self) -> &[u8] {
        match self.identifier.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.identifier.is_none() {
            self.identifier = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::vec::Vec<u8> {
        self.identifier.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 timestamp = 5;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // required sint32 time_zone_offset = 6;

    pub fn time_zone_offset(&self) -> i32 {
        self.time_zone_offset.unwrap_or(0)
    }

    pub fn clear_time_zone_offset(&mut self) {
        self.time_zone_offset = ::std::option::Option::None;
    }

    pub fn has_time_zone_offset(&self) -> bool {
        self.time_zone_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_zone_offset(&mut self, v: i32) {
        self.time_zone_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "coin_type",
            |m: &MimbleWimbleCoinGetLoginChallengeSignature| { &m.coin_type },
            |m: &mut MimbleWimbleCoinGetLoginChallengeSignature| { &mut m.coin_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_type",
            |m: &MimbleWimbleCoinGetLoginChallengeSignature| { &m.network_type },
            |m: &mut MimbleWimbleCoinGetLoginChallengeSignature| { &mut m.network_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account",
            |m: &MimbleWimbleCoinGetLoginChallengeSignature| { &m.account },
            |m: &mut MimbleWimbleCoinGetLoginChallengeSignature| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier",
            |m: &MimbleWimbleCoinGetLoginChallengeSignature| { &m.identifier },
            |m: &mut MimbleWimbleCoinGetLoginChallengeSignature| { &mut m.identifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &MimbleWimbleCoinGetLoginChallengeSignature| { &m.timestamp },
            |m: &mut MimbleWimbleCoinGetLoginChallengeSignature| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_zone_offset",
            |m: &MimbleWimbleCoinGetLoginChallengeSignature| { &m.time_zone_offset },
            |m: &mut MimbleWimbleCoinGetLoginChallengeSignature| { &mut m.time_zone_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinGetLoginChallengeSignature>(
            "MimbleWimbleCoinGetLoginChallengeSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinGetLoginChallengeSignature {
    const NAME: &'static str = "MimbleWimbleCoinGetLoginChallengeSignature";

    fn is_initialized(&self) -> bool {
        if self.coin_type.is_none() {
            return false;
        }
        if self.network_type.is_none() {
            return false;
        }
        if self.account.is_none() {
            return false;
        }
        if self.identifier.is_none() {
            return false;
        }
        if self.timestamp.is_none() {
            return false;
        }
        if self.time_zone_offset.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coin_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.network_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.account = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.identifier = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.time_zone_offset = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coin_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.time_zone_offset {
            my_size += ::protobuf::rt::sint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.coin_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.network_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.identifier.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.time_zone_offset {
            os.write_sint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinGetLoginChallengeSignature {
        MimbleWimbleCoinGetLoginChallengeSignature::new()
    }

    fn clear(&mut self) {
        self.coin_type = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.time_zone_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinGetLoginChallengeSignature {
        static instance: MimbleWimbleCoinGetLoginChallengeSignature = MimbleWimbleCoinGetLoginChallengeSignature {
            coin_type: ::std::option::Option::None,
            network_type: ::std::option::Option::None,
            account: ::std::option::Option::None,
            identifier: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            time_zone_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinGetLoginChallengeSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinGetLoginChallengeSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinGetLoginChallengeSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinGetLoginChallengeSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinLoginChallengeSignature)
pub struct MimbleWimbleCoinLoginChallengeSignature {
    // message fields
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinLoginChallengeSignature.login_public_key)
    pub login_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinLoginChallengeSignature.login_challenge_signature)
    pub login_challenge_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinLoginChallengeSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MimbleWimbleCoinLoginChallengeSignature {
    fn default() -> &'a MimbleWimbleCoinLoginChallengeSignature {
        <MimbleWimbleCoinLoginChallengeSignature as ::protobuf::Message>::default_instance()
    }
}

impl MimbleWimbleCoinLoginChallengeSignature {
    pub fn new() -> MimbleWimbleCoinLoginChallengeSignature {
        ::std::default::Default::default()
    }

    // required bytes login_public_key = 1;

    pub fn login_public_key(&self) -> &[u8] {
        match self.login_public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_login_public_key(&mut self) {
        self.login_public_key = ::std::option::Option::None;
    }

    pub fn has_login_public_key(&self) -> bool {
        self.login_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_login_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.login_public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_login_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.login_public_key.is_none() {
            self.login_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.login_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_login_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.login_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes login_challenge_signature = 2;

    pub fn login_challenge_signature(&self) -> &[u8] {
        match self.login_challenge_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_login_challenge_signature(&mut self) {
        self.login_challenge_signature = ::std::option::Option::None;
    }

    pub fn has_login_challenge_signature(&self) -> bool {
        self.login_challenge_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_login_challenge_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.login_challenge_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_login_challenge_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.login_challenge_signature.is_none() {
            self.login_challenge_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.login_challenge_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_login_challenge_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.login_challenge_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "login_public_key",
            |m: &MimbleWimbleCoinLoginChallengeSignature| { &m.login_public_key },
            |m: &mut MimbleWimbleCoinLoginChallengeSignature| { &mut m.login_public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "login_challenge_signature",
            |m: &MimbleWimbleCoinLoginChallengeSignature| { &m.login_challenge_signature },
            |m: &mut MimbleWimbleCoinLoginChallengeSignature| { &mut m.login_challenge_signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MimbleWimbleCoinLoginChallengeSignature>(
            "MimbleWimbleCoinLoginChallengeSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MimbleWimbleCoinLoginChallengeSignature {
    const NAME: &'static str = "MimbleWimbleCoinLoginChallengeSignature";

    fn is_initialized(&self) -> bool {
        if self.login_public_key.is_none() {
            return false;
        }
        if self.login_challenge_signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.login_public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.login_challenge_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.login_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.login_challenge_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.login_public_key.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.login_challenge_signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MimbleWimbleCoinLoginChallengeSignature {
        MimbleWimbleCoinLoginChallengeSignature::new()
    }

    fn clear(&mut self) {
        self.login_public_key = ::std::option::Option::None;
        self.login_challenge_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MimbleWimbleCoinLoginChallengeSignature {
        static instance: MimbleWimbleCoinLoginChallengeSignature = MimbleWimbleCoinLoginChallengeSignature {
            login_public_key: ::std::option::Option::None,
            login_challenge_signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MimbleWimbleCoinLoginChallengeSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MimbleWimbleCoinLoginChallengeSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MimbleWimbleCoinLoginChallengeSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimbleWimbleCoinLoginChallengeSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType)
pub enum MimbleWimbleCoinCoinType {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType.MIMBLEWIMBLE_COIN)
    MIMBLEWIMBLE_COIN = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType.GRIN)
    GRIN = 1,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinType.EPIC_CASH)
    EPIC_CASH = 2,
}

impl ::protobuf::Enum for MimbleWimbleCoinCoinType {
    const NAME: &'static str = "MimbleWimbleCoinCoinType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MimbleWimbleCoinCoinType> {
        match value {
            0 => ::std::option::Option::Some(MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN),
            1 => ::std::option::Option::Some(MimbleWimbleCoinCoinType::GRIN),
            2 => ::std::option::Option::Some(MimbleWimbleCoinCoinType::EPIC_CASH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MimbleWimbleCoinCoinType] = &[
        MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN,
        MimbleWimbleCoinCoinType::GRIN,
        MimbleWimbleCoinCoinType::EPIC_CASH,
    ];
}

impl ::protobuf::EnumFull for MimbleWimbleCoinCoinType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MimbleWimbleCoinCoinType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MimbleWimbleCoinCoinType {
    fn default() -> Self {
        MimbleWimbleCoinCoinType::MIMBLEWIMBLE_COIN
    }
}

impl MimbleWimbleCoinCoinType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MimbleWimbleCoinCoinType>("MimbleWimbleCoinCoinType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType)
pub enum MimbleWimbleCoinNetworkType {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType.MAINNET)
    MAINNET = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkType.TESTNET)
    TESTNET = 1,
}

impl ::protobuf::Enum for MimbleWimbleCoinNetworkType {
    const NAME: &'static str = "MimbleWimbleCoinNetworkType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MimbleWimbleCoinNetworkType> {
        match value {
            0 => ::std::option::Option::Some(MimbleWimbleCoinNetworkType::MAINNET),
            1 => ::std::option::Option::Some(MimbleWimbleCoinNetworkType::TESTNET),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MimbleWimbleCoinNetworkType] = &[
        MimbleWimbleCoinNetworkType::MAINNET,
        MimbleWimbleCoinNetworkType::TESTNET,
    ];
}

impl ::protobuf::EnumFull for MimbleWimbleCoinNetworkType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MimbleWimbleCoinNetworkType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MimbleWimbleCoinNetworkType {
    fn default() -> Self {
        MimbleWimbleCoinNetworkType::MAINNET
    }
}

impl MimbleWimbleCoinNetworkType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MimbleWimbleCoinNetworkType>("MimbleWimbleCoinNetworkType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddressType)
pub enum MimbleWimbleCoinAddressType {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddressType.MQS)
    MQS = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddressType.TOR)
    TOR = 1,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAddressType.SLATEPACK)
    SLATEPACK = 2,
}

impl ::protobuf::Enum for MimbleWimbleCoinAddressType {
    const NAME: &'static str = "MimbleWimbleCoinAddressType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MimbleWimbleCoinAddressType> {
        match value {
            0 => ::std::option::Option::Some(MimbleWimbleCoinAddressType::MQS),
            1 => ::std::option::Option::Some(MimbleWimbleCoinAddressType::TOR),
            2 => ::std::option::Option::Some(MimbleWimbleCoinAddressType::SLATEPACK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MimbleWimbleCoinAddressType] = &[
        MimbleWimbleCoinAddressType::MQS,
        MimbleWimbleCoinAddressType::TOR,
        MimbleWimbleCoinAddressType::SLATEPACK,
    ];
}

impl ::protobuf::EnumFull for MimbleWimbleCoinAddressType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MimbleWimbleCoinAddressType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MimbleWimbleCoinAddressType {
    fn default() -> Self {
        MimbleWimbleCoinAddressType::MQS
    }
}

impl MimbleWimbleCoinAddressType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MimbleWimbleCoinAddressType>("MimbleWimbleCoinAddressType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchType)
pub enum MimbleWimbleCoinSwitchType {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchType.NONE)
    NONE = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchType.REGULAR)
    REGULAR = 1,
}

impl ::protobuf::Enum for MimbleWimbleCoinSwitchType {
    const NAME: &'static str = "MimbleWimbleCoinSwitchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MimbleWimbleCoinSwitchType> {
        match value {
            0 => ::std::option::Option::Some(MimbleWimbleCoinSwitchType::NONE),
            1 => ::std::option::Option::Some(MimbleWimbleCoinSwitchType::REGULAR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MimbleWimbleCoinSwitchType] = &[
        MimbleWimbleCoinSwitchType::NONE,
        MimbleWimbleCoinSwitchType::REGULAR,
    ];
}

impl ::protobuf::EnumFull for MimbleWimbleCoinSwitchType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MimbleWimbleCoinSwitchType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MimbleWimbleCoinSwitchType {
    fn default() -> Self {
        MimbleWimbleCoinSwitchType::NONE
    }
}

impl MimbleWimbleCoinSwitchType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MimbleWimbleCoinSwitchType>("MimbleWimbleCoinSwitchType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinMessageType)
pub enum MimbleWimbleCoinMessageType {
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinMessageType.SENDING_TRANSACTION)
    SENDING_TRANSACTION = 0,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinMessageType.RECEIVING_TRANSACTION)
    RECEIVING_TRANSACTION = 1,
    // @@protoc_insertion_point(enum_value:hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinMessageType.CREATING_COINBASE)
    CREATING_COINBASE = 2,
}

impl ::protobuf::Enum for MimbleWimbleCoinMessageType {
    const NAME: &'static str = "MimbleWimbleCoinMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MimbleWimbleCoinMessageType> {
        match value {
            0 => ::std::option::Option::Some(MimbleWimbleCoinMessageType::SENDING_TRANSACTION),
            1 => ::std::option::Option::Some(MimbleWimbleCoinMessageType::RECEIVING_TRANSACTION),
            2 => ::std::option::Option::Some(MimbleWimbleCoinMessageType::CREATING_COINBASE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MimbleWimbleCoinMessageType] = &[
        MimbleWimbleCoinMessageType::SENDING_TRANSACTION,
        MimbleWimbleCoinMessageType::RECEIVING_TRANSACTION,
        MimbleWimbleCoinMessageType::CREATING_COINBASE,
    ];
}

impl ::protobuf::EnumFull for MimbleWimbleCoinMessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MimbleWimbleCoinMessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MimbleWimbleCoinMessageType {
    fn default() -> Self {
        MimbleWimbleCoinMessageType::SENDING_TRANSACTION
    }
}

impl MimbleWimbleCoinMessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MimbleWimbleCoinMessageType>("MimbleWimbleCoinMessageType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20messages-mimblewimble-coin.proto\x12$hw.trezor.messages.mimblewimb\
    le_coin\"\xff\x01\n\x20MimbleWimbleCoinGetRootPublicKey\x12[\n\tcoin_typ\
    e\x18\x01\x20\x02(\x0e2>.hw.trezor.messages.mimblewimble_coin.MimbleWimb\
    leCoinCoinTypeR\x08coinType\x12d\n\x0cnetwork_type\x18\x02\x20\x02(\x0e2\
    A.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkTypeR\x0bn\
    etworkType\x12\x18\n\x07account\x18\x03\x20\x02(\rR\x07account\"G\n\x1dM\
    imbleWimbleCoinRootPublicKey\x12&\n\x0froot_public_key\x18\x01\x20\x02(\
    \x0cR\rrootPublicKey\"\xf5\x02\n\x1aMimbleWimbleCoinGetAddress\x12[\n\tc\
    oin_type\x18\x01\x20\x02(\x0e2>.hw.trezor.messages.mimblewimble_coin.Mim\
    bleWimbleCoinCoinTypeR\x08coinType\x12d\n\x0cnetwork_type\x18\x02\x20\
    \x02(\x0e2A.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetwork\
    TypeR\x0bnetworkType\x12d\n\x0caddress_type\x18\x03\x20\x02(\x0e2A.hw.tr\
    ezor.messages.mimblewimble_coin.MimbleWimbleCoinAddressTypeR\x0baddressT\
    ype\x12\x18\n\x07account\x18\x04\x20\x02(\rR\x07account\x12\x14\n\x05ind\
    ex\x18\x05\x20\x02(\rR\x05index\"3\n\x17MimbleWimbleCoinAddress\x12\x18\
    \n\x07address\x18\x01\x20\x02(\tR\x07address\"\xfc\x01\n\x1dMimbleWimble\
    CoinGetSeedCookie\x12[\n\tcoin_type\x18\x01\x20\x02(\x0e2>.hw.trezor.mes\
    sages.mimblewimble_coin.MimbleWimbleCoinCoinTypeR\x08coinType\x12d\n\x0c\
    network_type\x18\x02\x20\x02(\x0e2A.hw.trezor.messages.mimblewimble_coin\
    .MimbleWimbleCoinNetworkTypeR\x0bnetworkType\x12\x18\n\x07account\x18\
    \x03\x20\x02(\rR\x07account\"=\n\x1aMimbleWimbleCoinSeedCookie\x12\x1f\n\
    \x0bseed_cookie\x18\x01\x20\x02(\x0cR\nseedCookie\"\x95\x03\n\x1dMimbleW\
    imbleCoinGetCommitment\x12[\n\tcoin_type\x18\x01\x20\x02(\x0e2>.hw.trezo\
    r.messages.mimblewimble_coin.MimbleWimbleCoinCoinTypeR\x08coinType\x12d\
    \n\x0cnetwork_type\x18\x02\x20\x02(\x0e2A.hw.trezor.messages.mimblewimbl\
    e_coin.MimbleWimbleCoinNetworkTypeR\x0bnetworkType\x12\x18\n\x07account\
    \x18\x03\x20\x02(\rR\x07account\x12\x1e\n\nidentifier\x18\x04\x20\x02(\
    \x0cR\nidentifier\x12\x14\n\x05value\x18\x05\x20\x02(\x04R\x05value\x12a\
    \n\x0bswitch_type\x18\x06\x20\x02(\x0e2@.hw.trezor.messages.mimblewimble\
    _coin.MimbleWimbleCoinSwitchTypeR\nswitchType\"<\n\x1aMimbleWimbleCoinCo\
    mmitment\x12\x1e\n\ncommitment\x18\x01\x20\x02(\x0cR\ncommitment\"\x86\
    \x04\n(MimbleWimbleCoinGetBulletproofComponents\x12[\n\tcoin_type\x18\
    \x01\x20\x02(\x0e2>.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoi\
    nCoinTypeR\x08coinType\x12d\n\x0cnetwork_type\x18\x02\x20\x02(\x0e2A.hw.\
    trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkTypeR\x0bnetwor\
    kType\x12d\n\x0cmessage_type\x18\x03\x20\x02(\x0e2A.hw.trezor.messages.m\
    imblewimble_coin.MimbleWimbleCoinMessageTypeR\x0bmessageType\x12\x18\n\
    \x07account\x18\x04\x20\x02(\rR\x07account\x12\x1e\n\nidentifier\x18\x05\
    \x20\x02(\x0cR\nidentifier\x12\x14\n\x05value\x18\x06\x20\x02(\x04R\x05v\
    alue\x12a\n\x0bswitch_type\x18\x07\x20\x02(\x0e2@.hw.trezor.messages.mim\
    blewimble_coin.MimbleWimbleCoinSwitchTypeR\nswitchType\"f\n%MimbleWimble\
    CoinBulletproofComponents\x12\x13\n\x05tau_x\x18\x01\x20\x02(\x0cR\x04ta\
    uX\x12\x13\n\x05t_one\x18\x02\x20\x02(\x0cR\x04tOne\x12\x13\n\x05t_two\
    \x18\x03\x20\x02(\x0cR\x04tTwo\"\x82\x02\n#MimbleWimbleCoinVerifyRootPub\
    licKey\x12[\n\tcoin_type\x18\x01\x20\x02(\x0e2>.hw.trezor.messages.mimbl\
    ewimble_coin.MimbleWimbleCoinCoinTypeR\x08coinType\x12d\n\x0cnetwork_typ\
    e\x18\x02\x20\x02(\x0e2A.hw.trezor.messages.mimblewimble_coin.MimbleWimb\
    leCoinNetworkTypeR\x0bnetworkType\x12\x18\n\x07account\x18\x03\x20\x02(\
    \rR\x07account\"\xf8\x02\n\x1dMimbleWimbleCoinVerifyAddress\x12[\n\tcoin\
    _type\x18\x01\x20\x02(\x0e2>.hw.trezor.messages.mimblewimble_coin.Mimble\
    WimbleCoinCoinTypeR\x08coinType\x12d\n\x0cnetwork_type\x18\x02\x20\x02(\
    \x0e2A.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinNetworkTypeR\
    \x0bnetworkType\x12d\n\x0caddress_type\x18\x03\x20\x02(\x0e2A.hw.trezor.\
    messages.mimblewimble_coin.MimbleWimbleCoinAddressTypeR\x0baddressType\
    \x12\x18\n\x07account\x18\x04\x20\x02(\rR\x07account\x12\x14\n\x05index\
    \x18\x05\x20\x02(\rR\x05index\"\xc6\x02\n$MimbleWimbleCoinStartEncryptin\
    gSlate\x12[\n\tcoin_type\x18\x01\x20\x02(\x0e2>.hw.trezor.messages.mimbl\
    ewimble_coin.MimbleWimbleCoinCoinTypeR\x08coinType\x12d\n\x0cnetwork_typ\
    e\x18\x02\x20\x02(\x0e2A.hw.trezor.messages.mimblewimble_coin.MimbleWimb\
    leCoinNetworkTypeR\x0bnetworkType\x12\x18\n\x07account\x18\x03\x20\x02(\
    \rR\x07account\x12\x14\n\x05index\x18\x04\x20\x02(\rR\x05index\x12+\n\
    \x11recipient_address\x18\x05\x20\x02(\x0cR\x10recipientAddress\"V\n*Mim\
    bleWimbleCoinEncryptedSlateNonceAndSalt\x12\x14\n\x05nonce\x18\x01\x20\
    \x02(\x0cR\x05nonce\x12\x12\n\x04salt\x18\x02\x20\x01(\x0cR\x04salt\"=\n\
    'MimbleWimbleCoinContinueEncryptingSlate\x12\x12\n\x04data\x18\x01\x20\
    \x02(\x0cR\x04data\"K\n\"MimbleWimbleCoinEncryptedSlateData\x12%\n\x0een\
    crypted_data\x18\x01\x20\x02(\x0cR\rencryptedData\"'\n%MimbleWimbleCoinF\
    inishEncryptingSlate\"u\n-MimbleWimbleCoinEncryptedSlateTagAndSignature\
    \x12\x10\n\x03tag\x18\x01\x20\x02(\x0cR\x03tag\x122\n\x15mqs_message_sig\
    nature\x18\x02\x20\x01(\x0cR\x13mqsMessageSignature\"\xf0\x03\n$MimbleWi\
    mbleCoinStartDecryptingSlate\x12[\n\tcoin_type\x18\x01\x20\x02(\x0e2>.hw\
    .trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinTypeR\x08coinType\
    \x12d\n\x0cnetwork_type\x18\x02\x20\x02(\x0e2A.hw.trezor.messages.mimble\
    wimble_coin.MimbleWimbleCoinNetworkTypeR\x0bnetworkType\x12\x18\n\x07acc\
    ount\x18\x03\x20\x02(\rR\x07account\x12\x14\n\x05index\x18\x04\x20\x02(\
    \rR\x05index\x12\x14\n\x05nonce\x18\x05\x20\x02(\x0cR\x05nonce\x12^\n-se\
    nder_address_or_ephemeral_x25519_public_key\x18\x06\x20\x02(\x0cR'sender\
    AddressOrEphemeralX25519PublicKey\x12:\n\x1asalt_or_encrypted_file_key\
    \x18\x07\x20\x01(\x0cR\x16saltOrEncryptedFileKey\x12#\n\rpayload_nonce\
    \x18\x08\x20\x01(\x0cR\x0cpayloadNonce\"P\n'MimbleWimbleCoinContinueDecr\
    yptingSlate\x12%\n\x0eencrypted_data\x18\x01\x20\x02(\x0cR\rencryptedDat\
    a\"8\n\"MimbleWimbleCoinDecryptedSlateData\x12\x12\n\x04data\x18\x01\x20\
    \x02(\x0cR\x04data\"9\n%MimbleWimbleCoinFinishDecryptingSlate\x12\x10\n\
    \x03tag\x18\x01\x20\x02(\x0cR\x03tag\"?\n$MimbleWimbleCoinDecryptedSlate\
    AesKey\x12\x17\n\x07aes_key\x18\x01\x20\x02(\x0cR\x06aesKey\"\x9d\x03\n\
    \x20MimbleWimbleCoinStartTransaction\x12[\n\tcoin_type\x18\x01\x20\x02(\
    \x0e2>.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinCoinTypeR\
    \x08coinType\x12d\n\x0cnetwork_type\x18\x02\x20\x02(\x0e2A.hw.trezor.mes\
    sages.mimblewimble_coin.MimbleWimbleCoinNetworkTypeR\x0bnetworkType\x12\
    \x18\n\x07account\x18\x03\x20\x02(\rR\x07account\x12\x14\n\x05index\x18\
    \x04\x20\x02(\rR\x05index\x12\x16\n\x06output\x18\x05\x20\x02(\x04R\x06o\
    utput\x12\x14\n\x05input\x18\x06\x20\x02(\x04R\x05input\x12\x10\n\x03fee\
    \x18\x07\x20\x02(\x04R\x03fee\x12,\n\x12secret_nonce_index\x18\x08\x20\
    \x02(\rR\x10secretNonceIndex\x12\x18\n\x07address\x18\t\x20\x01(\x0cR\
    \x07address\"\xcb\x01\n0MimbleWimbleCoinContinueTransactionIncludeOutput\
    \x12\x1e\n\nidentifier\x18\x01\x20\x02(\x0cR\nidentifier\x12\x14\n\x05va\
    lue\x18\x02\x20\x02(\x04R\x05value\x12a\n\x0bswitch_type\x18\x03\x20\x02\
    (\x0e2@.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchTypeR\
    \nswitchType\"\xca\x01\n/MimbleWimbleCoinContinueTransactionIncludeInput\
    \x12\x1e\n\nidentifier\x18\x01\x20\x02(\x0cR\nidentifier\x12\x14\n\x05va\
    lue\x18\x02\x20\x02(\x04R\x05value\x12a\n\x0bswitch_type\x18\x03\x20\x02\
    (\x0e2@.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinSwitchTypeR\
    \nswitchType\"H\n.MimbleWimbleCoinContinueTransactionApplyOffset\x12\x16\
    \n\x06offset\x18\x01\x20\x02(\x0cR\x06offset\"[\n+MimbleWimbleCoinTransa\
    ctionSecretNonceIndex\x12,\n\x12secret_nonce_index\x18\x01\x20\x01(\rR\
    \x10secretNonceIndex\"1\n/MimbleWimbleCoinContinueTransactionGetPublicKe\
    y\"E\n$MimbleWimbleCoinTransactionPublicKey\x12\x1d\n\npublic_key\x18\
    \x01\x20\x02(\x0cR\tpublicKey\"3\n1MimbleWimbleCoinContinueTransactionGe\
    tPublicNonce\"K\n&MimbleWimbleCoinTransactionPublicNonce\x12!\n\x0cpubli\
    c_nonce\x18\x01\x20\x02(\x0cR\x0bpublicNonce\"R\n6MimbleWimbleCoinContin\
    ueTransactionGetMessageSignature\x12\x18\n\x07message\x18\x01\x20\x02(\
    \x0cR\x07message\"Z\n+MimbleWimbleCoinTransactionMessageSignature\x12+\n\
    \x11message_signature\x18\x01\x20\x02(\x0cR\x10messageSignature\"\xcc\
    \x02\n!MimbleWimbleCoinFinishTransaction\x12d\n\x0caddress_type\x18\x01\
    \x20\x02(\x0e2A.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoinAdd\
    ressTypeR\x0baddressType\x12!\n\x0cpublic_nonce\x18\x02\x20\x02(\x0cR\
    \x0bpublicNonce\x12\x1d\n\npublic_key\x18\x03\x20\x02(\x0cR\tpublicKey\
    \x12-\n\x12kernel_information\x18\x04\x20\x02(\x0cR\x11kernelInformation\
    \x12+\n\x11kernel_commitment\x18\x05\x20\x01(\x0cR\x10kernelCommitment\
    \x12#\n\rpayment_proof\x18\x06\x20\x01(\x0cR\x0cpaymentProof\"x\n3Mimble\
    WimbleCoinTransactionSignatureAndPaymentProof\x12\x1c\n\tsignature\x18\
    \x01\x20\x02(\x0cR\tsignature\x12#\n\rpayment_proof\x18\x02\x20\x01(\x0c\
    R\x0cpaymentProof\"\xe5\x02\n(MimbleWimbleCoinGetMqsChallengeSignature\
    \x12[\n\tcoin_type\x18\x01\x20\x02(\x0e2>.hw.trezor.messages.mimblewimbl\
    e_coin.MimbleWimbleCoinCoinTypeR\x08coinType\x12d\n\x0cnetwork_type\x18\
    \x02\x20\x02(\x0e2A.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoi\
    nNetworkTypeR\x0bnetworkType\x12\x18\n\x07account\x18\x03\x20\x02(\rR\
    \x07account\x12\x14\n\x05index\x18\x04\x20\x02(\rR\x05index\x12\x1c\n\tt\
    imestamp\x18\x05\x20\x01(\x04R\ttimestamp\x12(\n\x10time_zone_offset\x18\
    \x06\x20\x01(\x11R\x0etimeZoneOffset\"_\n%MimbleWimbleCoinMqsChallengeSi\
    gnature\x126\n\x17mqs_challenge_signature\x18\x01\x20\x02(\x0cR\x15mqsCh\
    allengeSignature\"\xf1\x02\n*MimbleWimbleCoinGetLoginChallengeSignature\
    \x12[\n\tcoin_type\x18\x01\x20\x02(\x0e2>.hw.trezor.messages.mimblewimbl\
    e_coin.MimbleWimbleCoinCoinTypeR\x08coinType\x12d\n\x0cnetwork_type\x18\
    \x02\x20\x02(\x0e2A.hw.trezor.messages.mimblewimble_coin.MimbleWimbleCoi\
    nNetworkTypeR\x0bnetworkType\x12\x18\n\x07account\x18\x03\x20\x02(\rR\
    \x07account\x12\x1e\n\nidentifier\x18\x04\x20\x02(\x0cR\nidentifier\x12\
    \x1c\n\ttimestamp\x18\x05\x20\x02(\x04R\ttimestamp\x12(\n\x10time_zone_o\
    ffset\x18\x06\x20\x02(\x11R\x0etimeZoneOffset\"\x8f\x01\n'MimbleWimbleCo\
    inLoginChallengeSignature\x12(\n\x10login_public_key\x18\x01\x20\x02(\
    \x0cR\x0eloginPublicKey\x12:\n\x19login_challenge_signature\x18\x02\x20\
    \x02(\x0cR\x17loginChallengeSignature*J\n\x18MimbleWimbleCoinCoinType\
    \x12\x15\n\x11MIMBLEWIMBLE_COIN\x10\0\x12\x08\n\x04GRIN\x10\x01\x12\r\n\
    \tEPIC_CASH\x10\x02*7\n\x1bMimbleWimbleCoinNetworkType\x12\x0b\n\x07MAIN\
    NET\x10\0\x12\x0b\n\x07TESTNET\x10\x01*>\n\x1bMimbleWimbleCoinAddressTyp\
    e\x12\x07\n\x03MQS\x10\0\x12\x07\n\x03TOR\x10\x01\x12\r\n\tSLATEPACK\x10\
    \x02*3\n\x1aMimbleWimbleCoinSwitchType\x12\x08\n\x04NONE\x10\0\x12\x0b\n\
    \x07REGULAR\x10\x01*h\n\x1bMimbleWimbleCoinMessageType\x12\x17\n\x13SEND\
    ING_TRANSACTION\x10\0\x12\x19\n\x15RECEIVING_TRANSACTION\x10\x01\x12\x15\
    \n\x11CREATING_COINBASE\x10\x02BD\n#com.satoshilabs.trezor.lib.protobufB\
    \x1dTrezorMessageMimbleWimbleCoin\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(40);
            messages.push(MimbleWimbleCoinGetRootPublicKey::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinRootPublicKey::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinGetAddress::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinAddress::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinGetSeedCookie::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinSeedCookie::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinGetCommitment::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinCommitment::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinGetBulletproofComponents::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinBulletproofComponents::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinVerifyRootPublicKey::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinVerifyAddress::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinStartEncryptingSlate::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinEncryptedSlateNonceAndSalt::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinContinueEncryptingSlate::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinEncryptedSlateData::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinFinishEncryptingSlate::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinEncryptedSlateTagAndSignature::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinStartDecryptingSlate::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinContinueDecryptingSlate::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinDecryptedSlateData::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinFinishDecryptingSlate::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinDecryptedSlateAesKey::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinStartTransaction::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinContinueTransactionIncludeOutput::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinContinueTransactionIncludeInput::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinContinueTransactionApplyOffset::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinTransactionSecretNonceIndex::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinContinueTransactionGetPublicKey::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinTransactionPublicKey::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinContinueTransactionGetPublicNonce::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinTransactionPublicNonce::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinContinueTransactionGetMessageSignature::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinTransactionMessageSignature::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinFinishTransaction::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinTransactionSignatureAndPaymentProof::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinGetMqsChallengeSignature::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinMqsChallengeSignature::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinGetLoginChallengeSignature::generated_message_descriptor_data());
            messages.push(MimbleWimbleCoinLoginChallengeSignature::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(MimbleWimbleCoinCoinType::generated_enum_descriptor_data());
            enums.push(MimbleWimbleCoinNetworkType::generated_enum_descriptor_data());
            enums.push(MimbleWimbleCoinAddressType::generated_enum_descriptor_data());
            enums.push(MimbleWimbleCoinSwitchType::generated_enum_descriptor_data());
            enums.push(MimbleWimbleCoinMessageType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
